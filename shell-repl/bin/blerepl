#!/usr/bin/env python
from upydevice.bledevice import ble_scan, AsyncBleDevice
import argparse
import time
import sys
from binascii import hexlify
from upydev.shell.constants import style_p, shell_message, d_prompt
from upydev.shell.commands import _SHELL_FLAGS
from prompt_toolkit.filters import Condition
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from prompt_toolkit.auto_suggest import ConditionalAutoSuggest
from prompt_toolkit import PromptSession
from upydev.shell.shble import ShellBleCmds, shbl_cmd_kw
from upydev.shell.keybindings import ShellKeyBindings
from prompt_toolkit.application import in_terminal, run_in_terminal
import asyncio


_WASPDEV = ["P8", "PineTime", "Pixl.js"]
_IS_WASPDEV = False


# ARGPARSE HERE TO ACCEPT TARGET AND PASSWORD
parser = argparse.ArgumentParser()
parser.add_argument("-t", help='device uuid, can be "auto" or @name', required=True)
parser.add_argument("-v", help='verbose mode',
                    default=False, action='store_true')
parser.add_argument(
    "-dev", help='device name, default unique_id', required=False)
parser.add_argument("-r", help='reset on exit',
                    default=False, action='store_true')
parser.add_argument("-buff", help='Ble max writing length to use',
                    default=100, type=int)
args = parser.parse_args()


# HANDSHAKE
if args.t != "auto" and "@" not in args.t:
    basedev = AsyncBleDevice(args.t, name=args.dev, lenbuff=args.buff)
else:
    if args.t == "auto":
        devs = []
        while len(devs) == 0:
            try:
                devs = ble_scan()
            except KeyboardInterrupt:
                sys.exit()
        basedev = AsyncBleDevice(devs[0], lenbuff=args.buff)
    elif "@" in args.t:
        devs = []
        while len(devs) == 0:
            try:
                devs = ble_scan()
            except KeyboardInterrupt:
                sys.exit()
        bdev = args.t.split("@")[1]
        for dev in devs:
            if bdev in dev.name:
                basedev = AsyncBleDevice(devs[0], lenbuff=args.buff)
                break

basedev.connect(show_servs=args.v, debug=args.v)
if basedev.name in _WASPDEV:
    basedev.len_buffer = 20  # FIXME: INCREASE MTU SIZE IN NRF52
    _IS_WASPDEV = True
if not basedev.connected:
    print('Device not reachable, try again.')
    sys.exit()
# basedev.get_services()
if args.dev is not None:
    basedev.name = args.dev

time.sleep(0.2)
kbi = basedev.kbi()
time.sleep(0.2)
uid = basedev.wr_cmd("from machine import unique_id; unique_id()",
                     silent=True, rtn_resp=True)
try:
    unique_id = hexlify(uid).decode()
except Exception:
    unique_id = uid

time.sleep(0.2)
devp = basedev.wr_cmd("import sys; sys.platform", silent=True, rtn_resp=True)
dev_platform = devp
if args.v:
    print('{}@{}'.format(dev_platform, unique_id))
if basedev.name is None:
    basedev.name = '{}-{}'.format(dev_platform, unique_id)
# ble_cp = SERIAL_REPL_server(dev=espdev, dev_id=unique_id)
# shr_htool = SERIAL_TOOL(sh_srepl=ble_cp)
print('BLE SHELL-REPL connected')
time.sleep(0.2)
basedev.banner()
# ble_cp.sh_repl("\x02", banner=True)
# ble_cp.flush()
print('- CTRL-k to see keybindings or -h to see help\n'
      '- CTRL-s to toggle shell/repl mode\n'
      '- CTRL-x or "exit" to exit')

# SET DEV NAME
host_name = unique_id
if args.dev is not None:
    host_name = args.dev

shell_message[1] = ('class:username', dev_platform)
shell_message[3] = ('class:host', host_name)


# START IN SHELL MODE
if _SHELL_FLAGS.shell_mode['S']:
    _SHELL_FLAGS.prompt['p'] = d_prompt
    _SHELL_FLAGS.shell_mode['S'] = False
else:
    _SHELL_FLAGS.prompt['p'] = _SHELL_FLAGS.shell_prompt['s']
    _SHELL_FLAGS.shell_mode['S'] = True

    basedev.wr_cmd('import gc;import os;from upysh import *;from nanoglob import glob'
                   ';gc.collect()', silent=True)
    # # espdev.close_wconn()
    if not _IS_WASPDEV:
        basedev.wr_cmd("help('modules')", silent=True, long_string=True)
    # # espdev.open_wconn()
        _SHELL_FLAGS.frozen_modules['FM'] = basedev.output.split()[:-6]
    #
    basedev.output = None

# SHELL-COMMANDS
sh = ShellBleCmds(basedev, flags=_SHELL_FLAGS, topargs=args)

# KEYBINDINGS
kb = ShellKeyBindings(_SHELL_FLAGS, basedev, sh, shbl_cmd_kw)

# data = bytes(basedev._kbi + '\r', 'utf-8')
# await basedev.ble_client.write_gatt_char(basedev.writeables['Nordic UART RX'], data)
flags = _SHELL_FLAGS
kb.remove('c-c')
kb.remove('c-t')
kb.remove('c-d')
_dev_cmd_finished = True


@kb.add('c-t')
def runtempbuff(event):
    "Run contents of _tmp_script.py"
    def run_tmpcode():
        print('Running Buffer')
        with open('_tmp_script.py', 'r') as fbuff:
            filebuffer = fbuff.read()
        event.app.current_buffer.reset()
        basedev.paste_buff(filebuffer)
        event.app.current_buffer.reset()
        try:
            basedev.wr_cmd('\x04', follow=True, long_string=True)
        except KeyboardInterrupt:
            basedev.kbi()
    run_in_terminal(run_tmpcode)


@kb.add('c-d')
def paste_mode_exit(event):
    "PASTE MODE VIM EXEC, SOFT RESET IN REPL"
    # event.app.current_buffer.insert_text('import')

    def cmd_paste_exit():
        print('Running Buffer...')
        event.app.current_buffer.reset()
        try:
            basedev.wr_cmd('\x04', follow=True, long_string=True)
        except KeyboardInterrupt:
            basedev.kbi()
        flags.paste['p'] = False

    if flags.paste['p']:
        run_in_terminal(cmd_paste_exit)


@kb.add('c-c')
def send_KBI(event):

    async def run_kb():
        try:
            last_cmd = ''
            if flags.shell_mode['S']:
                print('^C')
                event.app.current_buffer.reset()
                flags.paste['p'] = False
                data = bytes(basedev._kbi + '\r', 'utf-8')
                await basedev.ble_client.write_gatt_char(basedev.writeables['Nordic UART RX'], data)
            else:

                data = bytes(basedev._kbi + '\r', 'utf-8')
                await basedev.ble_client.write_gatt_char(basedev.writeables['Nordic UART RX'], data)

                flags.paste['p'] = False
                if not flags.shell_mode['S']:
                    flags.prompt['p'] = d_prompt
                    last_cmd = event.app.current_buffer.document.text
                event.app.current_buffer.reset()
        except Exception as e:
            print(e)

        def cmd_kbi(command=last_cmd):
            if flags.prompt['p'] == ">>> ":
                print(flags.prompt['p'] + command)
        cmd_kbi()

        return None

    async def f():
        async with in_terminal():
            await run_kb()

    loop = asyncio.get_event_loop()
    loop.create_task(f())


@Condition
def autosuggest_is_on():
    return _SHELL_FLAGS.autosuggest['A']


# def check_prompt():
#     return _SHELL_FLAGS.prompt['p']

def check_prompt():
    if basedev.cmd_finished:
        return _SHELL_FLAGS.prompt['p']
    else:
        return ''


session_p = PromptSession()
# REPL/SHELL LOOP
repl = True
while repl:
    try:
        basedev.output = None
        if _SHELL_FLAGS.exit['exit']:
            break
        else:
            do_autsugg = ConditionalAutoSuggest(AutoSuggestFromHistory(),
                                                autosuggest_is_on)
            inp = session_p.prompt(check_prompt,
                                   auto_suggest=do_autsugg,
                                   key_bindings=kb, style=style_p,
                                   rprompt=sh.get_rprompt,
                                   refresh_interval=0.2)

            if inp is not None and inp != '' and not _SHELL_FLAGS.paste['p']:
                # HERE IN SHELL MODE PROCESS INPUT BEFORE SENDING # shlex.split
                if _SHELL_FLAGS.shell_mode['S']:  # SHELL
                    sh.cmd(inp)
                else:  # REPL
                    basedev.wr_cmd(inp, follow=True)
                if inp != '':  # PASTE BUFFER
                    pass
                    # paste_buffer['B'].append(inp)
    except Exception as e:
        print(e)
        continue
    except KeyboardInterrupt:
        continue
    except EOFError:
        # print('This is EOF ERROR!')
        continue
if basedev.connected and basedev.is_connected():

    basedev.disconnect()
print('logout')
if host_name != unique_id:
    print('Connection to {} closed.'.format(host_name))
else:
    print('Connection to {} closed.'.format(basedev.name))
