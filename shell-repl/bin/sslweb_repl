#!/usr/bin/env python3
from upydevice import Device
import argparse
import sys
from binascii import hexlify
import time
from upydev.shell.constants import style_p, shell_message, d_prompt
from upydev.shell.commands import _SHELL_FLAGS
from prompt_toolkit.filters import Condition
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from prompt_toolkit.auto_suggest import ConditionalAutoSuggest
from prompt_toolkit import PromptSession
from upydev.shell.shws import ShellWsCmds, shws_cmd_kw
from upydev.shell.keybindings import ShellKeyBindings


# ARGPARSE HERE TO ACCEPT TARGET AND PASSWORD
parser = argparse.ArgumentParser()
parser.add_argument("-p", help='host password', required=True)
parser.add_argument("-v", help='verbose mode',
                    default=False, action='store_true')
parser.add_argument("-t", help='host direction', required=True)
parser.add_argument("-ping", help='Test if device is reachable first',
                    required=False, action='store_true')
parser.add_argument(
    "-dev", help='device name, default unique_id', required=False)
parser.add_argument("-r", help='reset on exit',
                    default=False, action='store_true')
parser.add_argument("-nem",
                    help='No encryption mode, this bypass handshake and does not allow encryption afterwards',
                    default=False, action='store_true')
parser.add_argument("-wss",
                    help='Use WebSocket Secure to do initial handshake, this needs WebSecureREPL enabled "wss_repl.start(ssl=True)"',
                    default=False, action='store_true')
parser.add_argument("-zt", help='zerotier bridge; [HOST/FWD-HOST]',
                    default=None)

args = parser.parse_args()

# HANDSHAKE
espdev = Device(args.t, args.p)
ws_upydevice = espdev
base_ws = True
if args.ping:
    if espdev.is_reachable():
        pass
    else:
        print('DEVICE NOT REACHABLE')
        sys.exit()
if args.v:
    print('Welcome to SSLWebREPL 0.0.1!')
if not args.nem:
    if args.v:
        print('Initiating SECURE HANDSHAKE...')
# espdev.kbi(output=False)
if base_ws:
    get_psphrase = None
    # TODO: fix wrong passphrase loop
    if ws_upydevice.passphrase:
        ws_upydevice.connect()
        args.wss = True
        args.nem = True
    else:
        ws_upydevice.connect(ssl=args.wss, auth=args.wss)
    if args.wss:
        print(f'WebSecREPL with {ws_upydevice.ws.sock.version()} connected')
        print('{1} @ {0} - {2} bits Encryption'.format(*ws_upydevice.ws.sock.cipher()))
    ws_upydevice.wr_cmd(ws_upydevice._kbi)
    # espdev.wr_cmd("from machine import unique_id; unique_id()",
    #               silent=True)
    unique_id = ws_upydevice.wr_cmd("from machine import unique_id; "
                                    "unique_id()", silent=True, rtn_resp=True)
    # unique_id = hexlify(espdev.output).decode()
    try:
        unique_id = hexlify(unique_id).decode()
    except TypeError:
        time.sleep(0.5)
        unique_id = ws_upydevice.wr_cmd("from machine import unique_id; "
                                        "unique_id()", silent=True, rtn_resp=True)
        unique_id = hexlify(unique_id).decode()
    # espdev.wr_cmd("import sys; sys.platform",
    #               silent=True)
    dev_platform = ws_upydevice.wr_cmd("import sys; sys.platform", silent=True,
                                       rtn_resp=True)
    # dev_platform = espdev.output
    # espdev.platform = dev_platform
    ws_upydevice.platform = dev_platform
else:
    pass
    # espdev.open_wconn()
    # espdev.wr_cmd('C')
    # espdev.wr_cmd("from machine import unique_id; unique_id()",
    #               silent=True)
    # unique_id = hexlify(espdev.output).decode()
    # espdev.wr_cmd("import sys; sys.platform",
    #               silent=True)
    # dev_platform = espdev.output
    # espdev.platform = dev_platform
if args.v:
    print('{}@{}'.format(dev_platform, unique_id))
# rk = load_rsa_key(dir=upydev.__path__[0]+'/', show_key=False,
#                   id=unique_id)
# if rk is None:
#     sys.exit()
if not args.nem:
    pass
    # if base_ws:
    #     espdev = ws_upydevice
    # # check if device in ZeroTier group.
    # zt_file_conf = '_zt_upydev_.config'
    # zt_file_path = os.path.join(UPYDEV_PATH, zt_file_conf)
    # if zt_file_conf in os.listdir(UPYDEV_PATH):
    #     with open(zt_file_path, 'r', encoding='utf-8') as zt_conf:
    #         zt_devices = json.loads(zt_conf.read())
    #         if args.dev in zt_devices:
    #             args.zt = zt_devices[args.dev]
    #             if isinstance(args.zt, dict):
    #                 args.zt = args.zt["zt"]
    # ssl_cp = SSL_REPL_server(dev=espdev, key=ssl_key, cert=ssl_cert,
    #                          client_key=None, dev_id=unique_id, zt=args.zt)
    # ssl_htool = SSL_TOOL(ssl_repl=ssl_cp, key=ssl_key, cert=ssl_cert, zt=args.zt)
    # print('Done!')
    # if args.v:
    #     print('SSLWebREPL connected')
if args.nem:
    if base_ws:
        pass
        # ws_upydevice.close_wconn()
        # espdev.connect(ssl=args.wss)
    # fileargs = FileArgs()
    # fileargs.t = args.t
    # fileargs.p = args.p
    # fileargs.wss = args.wss
    # ssl_cp = WBREPL_IO(dev=espdev)
    if not args.wss:
        print('\033[91;1m' + 'WARNING: ENCRYPTION DISABLED IN THIS MODE' + '\033[0m')
        print('')
    print('')
# espdev.wr_cmd('B')
if not args.nem:
    pass
    # print('SSLWebREPL {} connected'.format(ssl_cp.version))
    # print('{1} @ {0} - {2} bits Encryption'.format(*ssl_cp.cipher))
    # # ssl_cp.ssl_repl("\x0d")
    # # time.sleep(0.2)
    # ssl_cp.ssl_repl("\x02", banner=True)
    # ssl_cp.flush_conn()
espdev.banner()
espdev.output = None

print('- CTRL-k to see keybindings or -h to see help\n'
      '- CTRL-s to toggle shell/repl mode\n'
      '- CTRL-x or "exit" to exit')
# PROMT SESSION CONFIGURATION

# Style


# SET DEV NAME
host_name = unique_id
if args.dev is not None:
    host_name = args.dev

shell_message[1] = ('class:username', dev_platform)
shell_message[3] = ('class:host', host_name)

# kb = KeyBindings()
# START IN SHELL MODE
if _SHELL_FLAGS.shell_mode['S']:
    _SHELL_FLAGS.prompt['p'] = d_prompt
    _SHELL_FLAGS.shell_mode['S'] = False
else:
    _SHELL_FLAGS.prompt['p'] = _SHELL_FLAGS.shell_prompt['s']
    _SHELL_FLAGS.shell_mode['S'] = True

    espdev.wr_cmd('import gc;import os;from upysh import *;from nanoglob import glob'
                  ';gc.collect()', silent=True)
    # espdev.close_wconn()
    espdev.wr_cmd("help('modules')", silent=True, long_string=True)
    # espdev.open_wconn()
    _SHELL_FLAGS.frozen_modules['FM'] = espdev.output.split()[:-6]

    espdev.output = None

# SHELL-COMMANDS
sh = ShellWsCmds(espdev, flags=_SHELL_FLAGS, topargs=args)

# KEYBINDINGS
kb = ShellKeyBindings(_SHELL_FLAGS, espdev, sh, shws_cmd_kw)


@Condition
def autosuggest_is_on():
    return _SHELL_FLAGS.autosuggest['A']


def check_prompt():
    return _SHELL_FLAGS.prompt['p']


session_p = PromptSession()

# REPL/SHELL LOOP
repl = True
while repl:
    try:
        espdev.output = None
        if _SHELL_FLAGS.exit['exit']:
            break
        else:
            do_autsugg = ConditionalAutoSuggest(AutoSuggestFromHistory(),
                                                autosuggest_is_on)
            inp = session_p.prompt(check_prompt,
                                   auto_suggest=do_autsugg,
                                   key_bindings=kb,
                                   style=style_p,
                                   refresh_interval=0.2,
                                   rprompt=sh.get_rprompt)

            if inp is not None and inp != '' and not _SHELL_FLAGS.paste['p']:
                # HERE IN SHELL MODE PROCESS INPUT BEFORE SENDING # shlex.split
                if _SHELL_FLAGS.shell_mode['S']:  # SHELL
                    sh.cmd(inp)
                else:  # REPL
                    espdev.wr_cmd(inp, follow=True)
                if inp != '':  # PASTE BUFFER
                    pass
                    # paste_buffer['B'].append(inp)
    except Exception as e:
        print(e)
        continue
    except KeyboardInterrupt:
        continue
    except EOFError:
        # print('This is EOF ERROR!')
        continue
        # espdev.reset()
        # sys.exit()

# sys.exit()
# EXIT MESSAGE
espdev.disconnect()
print('logout')
if host_name != unique_id:
    print('Connection to {} closed.'.format(host_name))
else:
    print('Connection to {} closed.'.format(args.t))
