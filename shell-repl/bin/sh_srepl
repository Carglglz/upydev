#!/usr/bin/env python3
from upydevice import Device
import argparse
import sys
from binascii import hexlify
import time
from upydev.shell.constants import style_p, shell_message, d_prompt
from upydev.shell.commands import _SHELL_FLAGS
from prompt_toolkit.filters import Condition
from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
from prompt_toolkit.auto_suggest import ConditionalAutoSuggest
from prompt_toolkit import PromptSession
from upydev.shell.shserial import ShellSrCmds, shsr_cmd_kw
from upydev.shell.keybindings import ShellKeyBindings


# ARGPARSE HERE TO ACCEPT TARGET AND PASSWORD
parser = argparse.ArgumentParser()
parser.add_argument("-p", help='device port', required=True)
parser.add_argument("-v", help='verbose mode',
                    default=False, action='store_true')
parser.add_argument("-t", help='device baudrate', default=115200)
parser.add_argument("-ping", help='Test if device is reachable first',
                    required=False, action='store_true')
parser.add_argument(
    "-dev", help='device name, default unique_id', required=False)
parser.add_argument("-r", help='reset on exit',
                    default=False, action='store_true')

args = parser.parse_args()


# HANDSHAKE
# HANDSHAKE
basedev = Device(args.p, args.t, autodetect=True, init=True)
espdev = basedev
if args.ping:
    if basedev.is_reachable():
        pass
    else:
        print('DEVICE NOT REACHABLE')
        sys.exit()
if args.v:
    print('Welcome to SERIAL SHELL-REPL 0.0.1!')

time.sleep(0.2)
# kbi = basedev.cmd('\x03\r', silent=True, rtn_resp=True)
uid = basedev.cmd("from machine import unique_id; unique_id()", silent=True,
                  rtn_resp=True)
try:
    unique_id = hexlify(uid).decode()
except Exception as e:
    unique_id = uid
# devp = basedev.cmd("import sys; sys.platform", silent=True,
#                    rtn_resp=True)
dev_platform = basedev.dev_platform
# espdev.platform = dev_platform
if args.v:
    print('{}@{}'.format(dev_platform, unique_id))
print('SERIAL SHELL-REPL connected')
espdev.banner()
print('- CTRL-k to see keybindings or -h to see help\n'
      '- CTRL-s to toggle shell/repl mode\n'
      '- CTRL-x or "exit" to exit')
# PROMT SESSION CONFIGURATION

# Style


# SET DEV NAME
host_name = unique_id
if args.dev is not None:
    host_name = args.dev

shell_message[1] = ('class:username', dev_platform)
shell_message[3] = ('class:host', host_name)

# kb = KeyBindings()
# START IN SHELL MODE
if _SHELL_FLAGS.shell_mode['S']:
    _SHELL_FLAGS.prompt['p'] = d_prompt
    _SHELL_FLAGS.shell_mode['S'] = False
else:
    _SHELL_FLAGS.prompt['p'] = _SHELL_FLAGS.shell_prompt['s']
    _SHELL_FLAGS.shell_mode['S'] = True

    espdev.wr_cmd('import gc;import os;from upysh import *;from nanoglob import glob'
                  ';gc.collect()', silent=True)
    # espdev.close_wconn()
    espdev.wr_cmd("help('modules')", silent=True, long_string=True)
    # espdev.open_wconn()
    _SHELL_FLAGS.frozen_modules['FM'] = espdev.output.split()[:-6]

    espdev.output = None

# SHELL-COMMANDS
sh = ShellSrCmds(espdev, flags=_SHELL_FLAGS, topargs=args)

# KEYBINDINGS
kb = ShellKeyBindings(_SHELL_FLAGS, espdev, sh, shsr_cmd_kw)


@Condition
def autosuggest_is_on():
    return _SHELL_FLAGS.autosuggest['A']


def check_prompt():
    return _SHELL_FLAGS.prompt['p']


session_p = PromptSession()

# REPL/SHELL LOOP
repl = True
while repl:
    try:
        espdev.output = None
        if _SHELL_FLAGS.exit['exit']:
            break
        else:
            inp = session_p.prompt(check_prompt,
                                   auto_suggest=ConditionalAutoSuggest(AutoSuggestFromHistory(),
                                                                       autosuggest_is_on),
                                   key_bindings=kb, style=style_p,
                                   multiline=_SHELL_FLAGS.edit_mode['E'] or _SHELL_FLAGS.paste['p'],
                                   refresh_interval=0.2)

            if inp is not None and inp != '' and not _SHELL_FLAGS.paste['p']:
                # HERE IN SHELL MODE PROCESS INPUT BEFORE SENDING # shlex.split
                if _SHELL_FLAGS.shell_mode['S']:  # SHELL
                    sh.cmd(inp)
                else:  # REPL
                    espdev.wr_cmd(inp, follow=True)
                if inp != '':  # PASTE BUFFER
                    pass
                    # paste_buffer['B'].append(inp)
    except Exception as e:
        print(e)
        continue
    except KeyboardInterrupt:
        continue
    except EOFError:
        # print('This is EOF ERROR!')
        continue
        # espdev.reset()
        # sys.exit()

# sys.exit()
# EXIT MESSAGE
espdev.disconnect()
print('logout')
if host_name != unique_id:
    print('Connection to {} closed.'.format(host_name))
else:
    print('Connection to {} closed.'.format(args.p))
