#!/usr/bin/env python
# PYTHON_ARGCOMPLETE_OK
# @Author: carlosgilgonzalez
# @Date:   2019-03-12T18:52:56+00:00
# @Last modified by:   carlosgilgonzalez
# @Last modified time: 2019-11-17T05:04:02+00:00

# upydev CLI
import argparse
import subprocess
import time
import sys
import json
import os
import shlex
import ast
import requests
import netifaces
import upydev
import socket
import struct
import glob
import signal
import multiprocessing
from datetime import datetime
from packaging import version
import argcomplete
from argcomplete.completers import ChoicesCompleter
from upydevice import BASE_WS_DEVICE
from ipaddress import ip_address
from upydevice import check_device_type, Device
from upydev.helpinfo import HELP_INFO_ARG, see_help

UPYDEV_PATH = upydev.__path__[0]

ADC_PINS_DICT = {'esp32h': [i for i in range(32, 40)]}

ATTEN_DICT = {0: 'ADC.ATTN_0DB', 1: 'ADC.ATTN_2_5DB', 2: 'ADC.ATTN_6DB',
              3: 'ADC.ATTN_11DB'}
ATTEN_INFO = """
0 = ADC.ATTN_0DB: 0dB attenuation, gives a maximum input voltage of 1.00v
1 = ADC.ATTN_2_5DB: 2.5dB attenuation, gives a maximum input voltage of approximately 1.34v
2 = ADC.ATTN_6DB: 6dB attenuation, gives a maximum input voltage of approximately 2.00v
3 = ADC.ATTN_11DB: 11dB attenuation, gives a maximum input voltage of approximately 3.6v
"""
log_levs = ['debug', 'info', 'warning', 'error', 'critical']


def serial_ports():
    ls_cmd_str = "/dev/tty.*"
    # print('Available Serial ports are:')
    # for port in glob.glob(ls_cmd_str):
    #     print(port)
    return glob.glob(ls_cmd_str)


def see_groups():
    avoid_files = ['upydev_.config', 'help.config', 'esp32h.config']
    local_cwd = [group_file.split('.')[0] for group_file in os.listdir(
    ) if '.config' in group_file and group_file not in 'upydev_.config']
    globl_wd = [group_file.split('.')[0] for group_file in os.listdir(
        upydev.__path__[0]) if '.config' in group_file and group_file not in avoid_files]
    return local_cwd + globl_wd


def see_global_devs(ws=True, serial=False, ble=False, all=False):
    # avoid_files = ['upydev_.config', 'help.config', 'esp32h.config']
    # # local_cwd = [group_file.split('.')[0] for group_file in os.listdir(
    # # ) if '.config' in group_file and group_file not in 'upydev_.config']
    # globl_wd = [group_file.split('.')[0] for group_file in os.listdir(
    #     upydev.__path__[0]) if '.config' in group_file and group_file not in avoid_files]
    try:
        with open('{}/UPY_G.config'.format(upydev.__path__[0]), 'r', encoding='utf-8') as group:
            devices = json.loads(group.read())
            # print(devices)
        if ws:
            devs = [dev for dev in devices if check_device_type(
                devices[dev][0]) == 'WebSocketDevice']
        if serial:
            devs = [dev for dev in devices if check_device_type(
                devices[dev][0]) == 'SerialDevice']
        if ble:
            devs = [dev for dev in devices if check_device_type(
                devices[dev][0]) == 'BleDevice']
        if all:
            devs = [dev for dev in devices]
        return devs
    except Exception as e:
        return []


#############################################
# ARGPARSER


helparg = HELP_INFO_ARG


usag = """%(prog)s ACTION [options]\n
This means that if the first argument ACTION is not a Mode keyword or a
upy command keyword it assumes it is a 'raw' upy command to send to the upy device \n
Requirements: Needs REPL to be accesible.
    > Wireless Devices:
        * WiFi: Needs WebREPL enabled in the device;
        see http://docs.micropython.org/en/latest/esp32/quickref.html#webrepl-web-browser-interactive-prompt

        * Bluetooth Low Energy: Needs BleREPL enabled in the device.
        see http://docs.micropython.org/en/latest/esp32/quickref.html#webrepl-web-browser-interactive-prompt

    > Serial Devices:
        * USB: Connected through USB data cable. """

# UPY MODE KEYWORDS AND COMMANDS
keywords_mode = ['put', 'get', 'sync', 'cmd', 'config', 'info', 'netinfo',
                 'netscan', 'i2c_scan', 'id', 'reset', 'upysh', 'wrepl',
                 'battery', 'meminfo', 'ping', 'du', 'df',
                 'uhelp', 'umodules', 'netinfot', 'netstat_on', 'netstat_off',
                 'netstat', 'ap_on', 'ap_off', 'apstat', 'apscan', 'run',
                 'apconfig', 'netstat_conn', 'i2c_config', 'imu_init',
                 'imuacc', 'imugy', 'imumag', 'pinout', 'specs', 'install',
                 'pin_status', 'adc_config', 'aread', 'set_ntptime',
                 'get_datetime', 'set_localtime', 'imuacc_sd', 'ads_init',
                 'ads_read', 'sd_enable', 'spi_config', 'sd_init', 'sd_deinit',
                 'sd_auto', 'dac_config', 'dac_write', 'dac_sig',
                 'buzz_config', 'buzz_set_alarm', 'buzz_interrupt',
                 'buzz_beep', 'servo_config', 'servo_angle', 'stepper_config',
                 'stepper_move', 'dcmotor_config', 'dcmotor_move',
                 'dcmotor_stop', 'mpyx', 'timeit', 'mqtt_config', 'mqtt_conn',
                 'mqtt_pub', 'mqtt_sub', 'mqtt_check', 'socli_init',
                 'socli_conn', 'socli_send', 'socli_recv', 'socli_close',
                 'sosrv_init', 'sosrv_start', 'sosrv_send', 'sosrv_recv',
                 'sosrv_close', 'rget_json', 'rget_text', 'fwr', 'flash',
                 'see', 'bme_init', 'bme_read', 'ina_init', 'ina_read',
                 'ina_batt', 'make_group', 'srepl', 'mg_group', 'find',
                 'wlan_init', 'wsta_config', 'wap_config', 'wsta_conn',
                 'wap_conn', 'kbi', 'diagnose', 'errlog', 'd_sync',
                 'stream_test', 'sysctl', 'log', 'update_upyutils',
                 'debug', 'gen_rsakey', 'rf_wrkey',
                 'sslgen_key', 'ssl_wrepl', 'ssl', 'sh_srepl', 'shr',
                 'wssl', 'wssrepl', 'set_wss', 'jupyterc', 'pytest',
                 'pytest-setup', 'check', 'ble', 'brepl', 'set', 'gg', 'probe',
                 'scan', 'repl', 'rpl', 'shell', 'shl', 'list', 'latest',
                 'rsa', 'wr', 'keygen', 'mkg', 'mkgroup', 'mgg', 'mggroup']

keywords_mode_help = ['%' + kw for kw in keywords_mode]
help_actions = ['help', 'h', 'dm', 'fio', 'fw', 'kg', 'rp', 'sh', 'db', 'gp',
                'gc', 'wu', 'sd', 'pro']

keywords_mode += help_actions

keywords_mode += ['shr@{}'.format(dev) for dev in see_global_devs(serial=True)]
keywords_mode += ['ssl@{}'.format(dev) for dev in see_global_devs()]
keywords_mode += ['wssl@{}'.format(dev) for dev in see_global_devs()]
keywords_mode += ['ble@{}'.format(dev) for dev in see_global_devs(ble=True)]
keywords_mode += ['rpl@{}'.format(dev) for dev in see_global_devs(all=True)]
keywords_mode += ['shl@{}'.format(dev) for dev in see_global_devs(all=True)]
help_dv = "To point the command to a specific device saved in the global group"

# ARG PARSER
parser = argparse.ArgumentParser(prog=upydev.name,
                                 description='Command line tool for wireless/serial MicroPython devices',
                                 formatter_class=argparse.RawTextHelpFormatter,
                                 usage=usag, prefix_chars='-')
parser.version = '{}: {}'.format(upydev.name, upydev.version)
parser.add_argument(
    "m", metavar='ACTION', help=helparg, nargs='+').completer = ChoicesCompleter(keywords_mode + keywords_mode_help)
parser.add_argument("-@", help=help_dv,
                    required=False).completer = ChoicesCompleter(see_global_devs(all=True))
parser.add_argument("-gg", help='global group flag', required=False,
                    action='store_true')
parser.add_argument("-p", help='password', required=False)
parser.add_argument("-f", help='script or file name', required=False)
parser.add_argument(
    "-lh", help='local ip for sync mode if can not be automatically detected',
    required=False)
parser.add_argument(
    "-t", help='target host for example : 192.168.1.40 or for AP 192.168.4.1',
    required=False)
parser.add_argument(
    "-sec", help='to configure a device password with no stream trace',
    required=False, default=False, action='store_true')
parser.add_argument(
    "-s", help='source dir in upy device, default is root dir (flash memory); sd for sd card source dir mounted as "/sd"', required=False)
parser.add_argument(
    "-dir", help='target dir in upy device, default is root dir (flash memory)', required=False)
parser.add_argument(
    "-tree", help='to see the tree structure of a the directory to sync', required=False, default=False, action='store_true')
parser.add_argument(
    "-c", help='command to send to upy device, do not wait for a response',
    required=False, type=str).completer = ChoicesCompleter(keywords_mode)
parser.add_argument(
    "-r", help='command to send to upy device, waits for a short response (one line)', required=False)
parser.add_argument(
    "-rl", help='command to send to upy device, waits for a longer response (multiple lines), so it can catch tracebacks messages', required=False)
parser.add_argument(
    "-g", help='to store/read the configuration file globally, if there is no config file in working directory, \n it uses the global file',
    required=False, default=False, action='store_true')
parser.add_argument(
    "-st", help='shows target ip if using config file', required=False, default=False, action='store_true')
parser.add_argument(
    "-rst", help='reset flag after put file operation, default true, "f" to disable', required=False)
parser.add_argument(
    "-ap", help='[essid] [password] to set AP name and password',
    required=False, nargs=2)
parser.add_argument(
    "-wp", help='[essid] [password] to connect the STA to an AP',
    required=False, nargs=2)
parser.add_argument(
    "-i2c", help='[SCL] [SDA] to config scl and sda i2c pins in upy device',
    required=False, nargs=2, default=[22, 23])
parser.add_argument(
    "-spi", help='[SCk] [MISO] [MOSI] [CS] to config scl and sda i2c pins in upy device',
    required=False, nargs=4, default=[5, 19, 18, 21], type=int)
parser.add_argument(
    "-b", help='[BOARD NAME] to request info of specs or of the pinouts',
    required=False).completer = ChoicesCompleter(['esp32', 'esp8266'])
parser.add_argument(
    "-att",
    help='[attenuation] for attenuation of adc input, default is 11dB attenuation, do -att info for more info',
    required=False, default=3)
parser.add_argument(
    "-tm",
    help='[timeout] enable stream mode and indicates a timeout in milliseconds',
    required=False, type=int)
parser.add_argument(
    "-po",
    help='[pin] indicates the pin to request info',
    required=False, nargs='+', type=int)

parser.add_argument(
    "-opt",
    help='wildcard option to be used by several commands',
    required=False, nargs='+', type=int)

parser.add_argument(
    "-n",
    help='tag a log shot from a sensor or adc',
    required=False)
parser.add_argument("-wss",
                    help='Use WebSocket Secure (not available for all commands), this needs WebSecureREPL enabled "wss_repl.start(ssl=True)"',
                    default=False, action='store_true')
parser.add_argument('-v', action='version')
parser.add_argument('-start', help='To start a script with sysctl; use as -start [SCRIPT_NAME]',
                    required=False)
parser.add_argument('-stop', help='To start a script with sysctl; use as -stop [SCRIPT_NAME]',
                    required=False)
parser.add_argument(
    '-dflev', help='debug file mode level, options [debug, info, warning, error, critical]; default=error', default='error').completer = ChoicesCompleter(log_levs)
parser.add_argument(
    '-dslev', help='debug sys.stdout mode level, options [debug, info, warning, error, critical]; default=debug', default='debug').completer = ChoicesCompleter(log_levs)
parser.add_argument(
    '-daemon', help='enable "daemon mode", uses nohup so this means running in background, output if any is redirected to [SCRIPT_NAME]_daemon.log', default=False, action='store_true')
parser.add_argument('-stopd', help='To stop a log daemon script',
                    default=False, action='store_true')
parser.add_argument('-follow', help='To follow a daemon log script file, indicate script with -f option',
                    default=False, action='store_true')
parser.add_argument('-rep', help='to save the report in a text file',
                    required=False, default=False, action='store_true')
parser.add_argument('-apmd', help='set target to 192.168.4.1',
                    required=False, default=False, action='store_true')
parser.add_argument('-chunk_tx', help='chunk size of data packets in kB to send for wifi speed test',
                    required=False, default=20, type=int)
parser.add_argument('-chunk_rx', help='chunk size of data packets in kB to receive for wifi speed test',
                    required=False, default=32, type=int)
parser.add_argument('-total_size', help='total size of data packets in MB for wifi speed test',
                    required=False, default=10, type=int)
parser.add_argument('-show_key', help='show RSA key',
                    required=False, default=False, action='store_true')
parser.add_argument('-tfkey', help='transfer RSA/ECDSA key,ideally this should be done only if connected to the AP of the device',
                    required=False, default=False, action='store_true')
parser.add_argument('-key_size', help='Indicate RSA key length in bits (default is 2048)',
                    required=False, default=2048, type=int)
parser.add_argument('-rkey', help='To refresh password after WebREPL disconnection',
                    required=False, default=False, action='store_true')
parser.add_argument('-localkey_id', help='To refresh password manually of a current WebREPL connection',
                    required=False)
parser.add_argument('-nem', help='To initiate CryptoWebREPL/SSLWebREPL in unencrypted mode only',
                    required=False, default=False, action='store_true')
parser.add_argument('-utc', help='utc zone for set_nptime command', type=int,
                    default=0)
parser.add_argument('-imu', help='to select the imu library',
                    default='lsm9ds1')
parser.add_argument('-ads', help='to select the ads library and config options',
                    default='ads1115')
parser.add_argument('-ch', help='to select the ads analog channel to read from',
                    type=int, default=0)
parser.add_argument('-bme', help='to select the bme library and config options',
                    default='bme280')
parser.add_argument('-ina', help='to select the ina library and config options',
                    default='ina219')
parser.add_argument('-batt', help='to indicate battery capacity',
                    type=int, nargs='+')
parser.add_argument('-sig', help='to indicate a value or type of signal to write',
                    nargs='+')
parser.add_argument('-at', help='[HOUR] [MINUTE] [SECONDS]',
                    nargs='+', type=int, default=[0, 0, 0])
parser.add_argument('-to', help='[DIRECTION] [VELOCITY] [STEPS]',
                    nargs='+', default=['R', 2000, 100])

parser.add_argument('-client', help='[ID] [BROKER ADDRESS] [USER] [PASSWORD]',
                    nargs='+', default=[None, 'test.mosquitto.org'])
parser.add_argument('-server', help='For Client Socket:[IP] [PORT] [BUFFER LENGTH]; Server Socket [PORT] [BUFFER LENGTH]',
                    nargs='+')
parser.add_argument('-md', help='for command suboptions',
                    nargs='+').completer = ChoicesCompleter(['list', 'get', 'serial_ports', 'latest'])
parser.add_argument(
    '-port', help='serial port of the device to flash to').completer = ChoicesCompleter(serial_ports())
parser.add_argument('-devs', help='to indicate the devices that will be part of a group, use as -devs [DEV_1] [IP_1] [PASS_1] [DEV_2]...',
                    nargs='+')
parser.add_argument('-add', help='to indicate the devices that will be added to a group, use as -add [DEV_1] [IP_1] [PASS_1] [DEV_2]...',
                    nargs='+')
parser.add_argument('-rm', help='to indicate the devices that will be removed from a group, use as -rm [DEV_1] [DEV_2]...',
                    nargs='+')
parser.add_argument(
    '-G', help='to indicate the group of devices that the command is directed to').completer = ChoicesCompleter(see_groups())
parser.add_argument('-fre', help='special option to put or get files from upy device, can be "cwd", an expresion to match or name of files',
                    nargs='+')
parser.add_argument('-wdl', help='option to create and check a watchdog log file in cwd, so only new or modified files are uploaded',
                    default=False, action='store_true')
parser.add_argument('-swdl', help='flag used internally for -wdl mode',
                    default=True, action='store_false')
parser.add_argument('-i', help='Show extensive device information with check command',
                    default=False, action='store_true')
parser.add_argument('-sr', help='Serial scan flag for scan command',
                    default=False, action='store_true')
parser.add_argument('-bl', help='Bluetooth Low Energy scan flag for scan command',
                    default=False, action='store_true')
parser.add_argument('-nt', help='Local Area Network scan flag for scan command',
                    default=False, action='store_true')
parser.add_argument(
    '-GP', help='to indicate the group of devices that the command is directed to, for parallel command execution').completer = ChoicesCompleter(see_groups())
argcomplete.autocomplete(parser)
args = parser.parse_args()

multiple_args_fio = ['put', 'get', 'sync', 'install', 'd_sync', 'run', 'timeit',
                     'pytest', 'make_group', 'mg_group']
multiple_args_fw = ['fwr', 'flash', 'mpyx']

if len(args.m) == 1:
    args.m = args.m[0]

elif len(args.m) == 2:
    second_arg = args.m[1]
    args.m = args.m[0]
    if args.m in multiple_args_fio:
        args.f = second_arg
        if args.f == 'cwd' or '*' in args.f or args.f == '.':
            args.fre = [args.f]
    elif args.m in multiple_args_fw:
        if args.m == 'fwr':
            args.md = [second_arg]
        elif args.m == 'flash' or args.m == 'mpyx':
            args.f = second_arg
    elif args.m == 'kg' or args.m == 'keygen':
        if second_arg == 'rsa':
            args.m = 'gen_rsakey'
        elif second_arg == 'wr':
            args.m = 'rf_wrkey'
        elif second_arg == 'ssl':
            args.m = 'sslgen_key'
    elif args.m == 'sd':
        if second_arg == 'enable':
            args.m == 'sd_enable'
        elif second_arg == 'init':
            args.m == 'sd_init'
        elif second_arg == 'deinit':
            args.m == 'sd_deinit'
        elif second_arg == 'auto':
            args.m == 'sd_auto'
    elif args.m == 'mkgroup' or args.m == 'mkg':
        args.m = 'make_group'
        args.f = second_arg
    elif args.m == 'mggroup' or args.m == 'mgg':
        args.m = 'mg_group'
        args.G = second_arg
    elif args.m == 'see':
        args.G = second_arg

elif len(args.m) > 2:
    rest_args = args.m[1:]
    args.m = args.m[0]
    if args.m in multiple_args_fio:
        args.fre = rest_args
    elif args.m in multiple_args_fw:
        if args.m == 'fwr':
            args.md = rest_args
        elif args.m == 'flash':
            args.f = rest_args[0]
            args.port = rest_args[1]
# print(args.m, args.f, args.fre, args.md)
# sys.exit()

# DEVICE MANAGEMENT ACTIONS

DEVICE_MANAGEMENT_ACTIONS = ['config', 'check', 'set', 'make_group',
                             'mg_group', 'gg', 'see']

# FIRMWARE ACTIONS

FIRMWARE_ACTIONS = ['mpyx', 'fwr', 'flash']


# KEYGEN ACTIONS

KEYGEN_ACTIONS = ['gen_rsakey', 'rf_wrkey', 'sslgen_key']

# REPL ACTIONS

REPL_ACTIONS = ['repl', 'rpl', 'wrepl', 'wssrepl', 'srepl', 'brepl']

# SHELL-REPL ACTIONS

SHELL_REPL_ACTIONS = ['ssl_wrepl', 'ssl', 'sh_srepl', 'shr', 'wssl', 'set_wss',
                      'ble', 'jupyterc', 'shell', 'shl']

# DEBUGGING ACTIONS

DEBUGGING_ACTIONS = ['ping', 'probe', 'scan', 'run', 'timeit', 'diagnose', 'errlog',
                     'stream_test', 'sysctl', 'log', 'pytest-setup', 'pytest']

# FILEIO ACTIONS

FILEIO_ACTIONS = ['put', 'get', 'update_upyutils', 'install', 'sync', 'd_sync']

# GENERAL COMMANDS
GENERAL_COMMANDS = ['info', 'id', 'upysh', 'reset', 'kbi',
                    'uhelp', 'umodules', 'meminfo', 'du', 'df',
                    'netinfo', 'netinfot', 'netscan', 'netstat_on',
                    'netstat_off', 'netstat_conn', 'netstat', 'ap_on',
                    'ap_off', 'apstat', 'apconfig', 'apscan', 'i2c_config',
                    'i2c_scan', 'spi_config', 'set_localtime', 'set_ntptime',
                    'get_datetime', 'gc']
# WLAN COMMANDS

WLAN_UTILS_COMMANDS = ['wlan_init', 'wsta_config', 'wap_config', 'wsta_conn',
                       'wap_conn', 'wu']

# SD COMMANDS
SD_UTILS_COMMANDS = ['sd', 'sd_enable', 'sd_init', 'sd_deinit', 'sd_auto']

# PROTOTYPE
PROTOTYPE_COMMANDS = ['pro']

#############################################


def see_groups():
    avoid_files = ['upydev_.config', 'help.config', 'esp32h.config']
    local_cwd = [group_file.split('.')[0] for group_file in os.listdir(
    ) if '.config' in group_file and group_file not in 'upydev_.config']
    globl_wd = [group_file.split('.')[0] for group_file in os.listdir(
        upydev.__path__[0]) if '.config' in group_file and group_file not in avoid_files]
    return local_cwd + globl_wd


def run_command_rl(command):
    end = False
    lines = []
    process = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE)
    while end is not True:
        if process.poll() is None:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                line = output.strip().decode()
                lines.append(line)
                if output.strip() == b'### closed ###':
                    end = True
        else:
            break
    rc = process.poll()
    return rc, lines


def get_ip():
    # scanoutput = subprocess.check_output(["ipconfig", "getifaddr", "en0"])
    # ip = scanoutput.decode('utf-8').split('\n')[0]
    try:
        ip = [netifaces.ifaddresses(iface)[netifaces.AF_INET][0]['addr'] for
              iface in netifaces.interfaces() if netifaces.AF_INET in
              netifaces.ifaddresses(iface)][-1]
        return ip
    except Exception as e:
        try:
            ip_soc = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            ip_soc.connect(('8.8.8.8', 1))
            local_ip = ip_soc.getsockname()[0]
            ip_soc.close()
            return local_ip
        except Exception as e:
            return '0.0.0.0'


# def get_ssid():
#     if _platform == "linux" or _platform == "linux2":
#         ssid = ''
#         try:
#             output = subprocess.check_output(['sudo', 'iwgetid'])
#             ssid = output.split('"')[1]
#         except Exception as e:
#             print(e)
#         return ssid
#     elif _platform == "darwin":
#        # MAC OS X
#         scanoutput = subprocess.check_output(["airport", "-I"])
#         wifi_info = [data.strip()
#                      for data in scanoutput.decode('utf-8').split('\n')]
#         wifi_info_dic = {data.split(':')[0]: data.split(
#             ':')[1].strip() for data in wifi_info[:-1]}
#         return wifi_info_dic['SSID']


def get_live_stream(run_cmd, targ, password, sensorlib, filename=None,
                    r_format='fff', nb=12, log=False, variables=None):
    if args.lh is None:
        local_ip = get_ip()
    if args.lh is not None:
        local_ip = args.lh

    # START A LOCAL SERVER
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((local_ip, 8005))
    server_socket.listen(1)
    connect_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        '{}.connect_SOC({})'.format(sensorlib, "'{}'".format(
                                                     local_ip)), args.t, args.p)
    cmd_resp = run_command_rl(connect_cmd_str)
    conn, addr = server_socket.accept()
    conn.settimeout(1)
    flushed = 0
    while flushed == 0:
        try:
            conn.recv(1024)
        except Exception as e:
            flushed = 1
    if args.tm > 500:
        conn.settimeout((args.tm/1000)*3)  # for long periodic shots
    run_cmd_str = 'upycmd_r -c "{}" -t {} -p {}'.format(
        run_cmd, targ, password)
    run_live_cmd = shlex.split(run_cmd_str)
    comm = subprocess.call(run_live_cmd)
    print(('{:^15}'*len(variables)).format(*variables))
    try:
        if log:
            while True:
                try:
                    data_acc = conn.recv(nb)
                    decode = dict(zip(variables,
                                      struct.unpack(r_format, data_acc)))
                    decode_print = dict(zip(variables,
                                            [format(val, '.4f') for val in struct.unpack(r_format, data_acc)]))
                    sys.stdout.write("\033[K")
                    print(('{:^15}'*len(decode_print.values())
                           ).format(*decode_print.values()), end='\r')
                    sys.stdout.flush()
                    with open(filename, 'a') as logfile:
                        logfile.write(json.dumps(decode))
                        logfile.write('\n')
                except Exception as e:
                    print(e)
                    if str(e) == 'timed out':
                        pass
                    else:
                        break
        else:
            while True:
                try:
                    data_acc = conn.recv(nb)
                    decode = dict(zip(variables,
                                      [format(val, '.4f') for val in struct.unpack(r_format, data_acc)]))
                    sys.stdout.write("\033[K")
                    print(('{:^15}'*len(decode.values())
                           ).format(*decode.values()), end='\r')
                    sys.stdout.flush()
                except Exception as e:
                    # print(e)
                    if str(e) == 'timed out':
                        pass
                    else:
                        break

    except KeyboardInterrupt:
        try:
            print('\n')
            print('...closing...')
            conn.shutdown(socket.SHUT_RDWR)
            time.sleep(1)
            # Flush error keyboardinterrupt
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            time.sleep(1)
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            print('Done!')
            conn.close()
        except KeyboardInterrupt:
            print('...wait for closing...')
            conn.shutdown(socket.SHUT_RDWR)
            # Flush error keyboardinterrupt
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            time.sleep(1)
            conn.close()
            print('Done!')


def test_stream(run_cmd, targ, password, sensorlib, filename=None,
                r_format='fff', nb=12, log=False, variables=None, BUFFERSIZE=1):
    if args.lh is None:
        local_ip = get_ip()
    if args.lh is not None:
        local_ip = args.lh

    # START A LOCAL SERVER
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((local_ip, 8005))
    server_socket.listen(1)
    connect_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        '{}.connect_SOC({})'.format(sensorlib, "'{}'".format(
                                                     local_ip)), args.t, args.p)
    cmd_resp = run_command_rl(connect_cmd_str)
    conn, addr = server_socket.accept()
    conn.settimeout(1)
    flushed = 0
    while flushed == 0:
        try:
            conn.recv(1024)
        except Exception as e:
            flushed = 1
    if args.tm > 500:
        conn.settimeout((args.tm/1000)*3)  # for long periodic shots
    run_cmd_str = 'upycmd_r -c "{}" -t {} -p {}'.format(
        run_cmd, targ, password)
    run_live_cmd = shlex.split(run_cmd_str)
    subprocess.call(run_live_cmd)
    print(('{:^15}'*len(variables)).format(*variables))
    t0 = time.time()
    test_val = []
    try:
        if log:
            while True:
                try:
                    data_acc = conn.recv(nb)
                    decode = dict(zip(variables,
                                      struct.unpack(r_format, data_acc)))
                    decode_print = dict(zip(variables,
                                            [format(val, '.4f') for val in struct.unpack(r_format, data_acc)]))
                    sys.stdout.write("\033[K")
                    print(('{:^15}'*len(decode_print.values())
                           ).format(*decode_print.values()), end='\r')
                    sys.stdout.flush()
                    with open(filename, 'a') as logfile:
                        logfile.write(json.dumps(decode))
                        logfile.write('\n')
                except Exception as e:
                    print(e)
                    if str(e) == 'timed out':
                        pass
                    else:
                        break
        else:
            while True:
                try:
                    data_acc = conn.recv(nb)
                    decode = dict(zip(variables,
                                      struct.unpack(r_format, data_acc)))
                    decode_p = dict(zip(variables,
                                        [format(val, '.4f') for val in struct.unpack(r_format, data_acc)]))
                    sys.stdout.write("\033[K")
                    print(('{:^15}'*len(decode_p.values())
                           ).format(*decode_p.values()), end='\r')
                    sys.stdout.flush()
                    test_val.append(decode)
                    if t0 == 0:
                        t0 = time.time()

                    final_time = abs(time.time()-t0)
                except Exception as e:
                    # print(e)
                    if str(e) == 'timed out':
                        pass
                    else:
                        break

    except KeyboardInterrupt:
        try:
            print('\n')
            print('...closing...')
            conn.shutdown(socket.SHUT_RDWR)
            time.sleep(1)
            # Flush error keyboardinterrupt
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            time.sleep(1)
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            print('Done!')
            print('TEST RESULTS ARE:')
            print('TEST DURATION : {} (s)'.format(final_time))
            # # FIND SAMPLING RATE
            # Method 1:
            N_DATA_PACKETS = len(test_val)  # Number of batches received
            print('DATA PACKETS : {} packets'.format(N_DATA_PACKETS))
            # (assuming al batches = buffer_size long)
            Fs = ((N_DATA_PACKETS+1)*BUFFERSIZE/final_time)
            print('SAMPLES PER PACKET : {}'.format(BUFFERSIZE))
            print('VARIABLES PER SAMPLE : {}; {}'.format(
                len(variables), variables))
            print('SIZE OF PACKETS: {} bytes'.format(nb))
            #  32 is batch/buffer size ,
            # so total samples is n_batches (len(vals)) x size_batch
            # print('Period: {} ms ; Fs:{} Hz'.format(
            # timestamp[:].mean()/1e3,1/((timestamp[:].mean())/1e6))
            conn.close()
            print('Period: {} ms ; Fs:{} Hz, Data send rate: {} packets/s of {} samples'.format(
                round((1/Fs)*1e3), round(Fs, -1),
                round(N_DATA_PACKETS/final_time), BUFFERSIZE))
            print(
                'DATA TRANSFER RATE: {} KB/s'.format(round(N_DATA_PACKETS/final_time)*nb/1024))
        except KeyboardInterrupt:
            conn.shutdown(socket.SHUT_RDWR)
            print('...wait for closing...')
            # Flush error keyboardinterrupt
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            time.sleep(1)
            conn.close()
            print('Done!')


def get_live_stream_chunk(run_cmd, targ, password, sensorlib, filename=None,
                          r_format='h'*20, nb=40, log=False, variables=None):
    if args.lh is None:
        local_ip = get_ip()
    if args.lh is not None:
        local_ip = args.lh

    # START A LOCAL SERVER
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((local_ip, 8005))
    server_socket.listen(1)
    connect_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        '{}.connect_SOC({})'.format(sensorlib, "'{}'".format(
                                                     local_ip)), args.t, args.p)
    cmd_resp = run_command_rl(connect_cmd_str)
    conn, addr = server_socket.accept()
    conn.settimeout(1)
    flushed = 0
    while flushed == 0:
        try:
            conn.recv(1024)
        except Exception as e:
            flushed = 1
    if args.tm > 500:
        conn.settimeout((args.tm/1000)*3)  # for long periodic shots
    run_cmd_str = 'upycmd_r -c "{}" -t {} -p {}'.format(
        run_cmd, targ, password)
    run_live_cmd = shlex.split(run_cmd_str)
    subprocess.call(run_live_cmd)
    time.sleep(0.5)
    print(('{:^15}'*len(variables)).format(*variables))
    try:
        if log:
            while True:
                try:
                    data_acc = conn.recv(nb)
                    decode = dict(zip(variables,
                                      [struct.unpack(r_format, data_acc)]))
                    # print(decode)
                    for chunk in decode.values():
                        value = sum([val for val in chunk])/len(chunk)
                        sys.stdout.write("\033[K")
                        decode_p = dict(zip(variables,
                                            [format(value, '.4f')]))
                        print(('{:^15}'*len(decode_p.values())
                               ).format(*decode_p.values()), end='\r')
                        sys.stdout.flush()
                    with open(filename, 'a') as logfile:
                        logfile.write(json.dumps(decode))
                        logfile.write('\n')
                except Exception as e:
                    # print(e)
                    if str(e) == 'timed out':
                        pass
                    else:
                        break
        else:
            while True:
                try:
                    data_acc = conn.recv(nb)
                    decode = dict(zip(variables,
                                      [struct.unpack(r_format, data_acc)]))
                    # print(decode)
                    for chunk in decode.values():
                        value = sum([val for val in chunk])/len(chunk)
                        sys.stdout.write("\033[K")
                        decode_p = dict(zip(variables,
                                            [format(value, '.4f')]))
                        print(('{:^15}'*len(decode_p.values())
                               ).format(*decode_p.values()), end='\r')
                        sys.stdout.flush()
                        # print(dict(zip(variables, [value])))

                except Exception as e:
                    # print(e)
                    if str(e) == 'timed out':
                        pass
                    else:
                        print(e)
                        break

    except KeyboardInterrupt:
        try:
            print('\n')
            print('...closing...')
            conn.shutdown(socket.SHUT_RDWR)
            time.sleep(1)
            # Flush error keyboardinterrupt
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            time.sleep(1)
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            print('Done!')
            conn.close()
        except KeyboardInterrupt:
            conn.shutdown(socket.SHUT_RDWR)
            print('...wait for closing...')
            # Flush error keyboardinterrupt
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            time.sleep(1)
            conn.close()
            print('Done!')


def test_stream_chunk(run_cmd, targ, password, sensorlib, filename=None,
                      r_format='h'*20, nb=40, log=False, variables=None, BUFFERSIZE=20):
    if args.lh is None:
        local_ip = get_ip()
    if args.lh is not None:
        local_ip = args.lh

    # START A LOCAL SERVER
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((local_ip, 8005))
    server_socket.listen(1)
    connect_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        '{}.connect_SOC({})'.format(sensorlib, "'{}'".format(
                                                     local_ip)), args.t, args.p)
    cmd_resp = run_command_rl(connect_cmd_str)
    conn, addr = server_socket.accept()
    conn.settimeout(1)
    flushed = 0
    while flushed == 0:
        try:
            conn.recv(1024)
        except Exception as e:
            flushed = 1
    if args.tm > 500:
        conn.settimeout((args.tm/1000)*3)  # for long periodic shots
    run_cmd_str = 'upycmd_r -c "{}" -t {} -p {}'.format(
        run_cmd, targ, password)
    run_live_cmd = shlex.split(run_cmd_str)
    subprocess.call(run_live_cmd)
    time.sleep(0.5)
    t0 = time.time()
    test_val = []
    print(('{:^15}'*len(variables)).format(*variables))
    try:
        if log:
            while True:
                try:
                    data_acc = conn.recv(nb)
                    decode = dict(zip(variables,
                                      [struct.unpack(r_format, data_acc)]))
                    # print(decode)
                    for chunk in decode.values():
                        value = sum([val for val in chunk])/len(chunk)
                        sys.stdout.write("\033[K")
                        decode_p = dict(zip(variables,
                                            [format(value, '.4f')]))
                        print(('{:^15}'*len(decode_p.values())
                               ).format(*decode_p.values()), end='\r')
                        sys.stdout.flush()
                    with open(filename, 'a') as logfile:
                        logfile.write(json.dumps(decode))
                        logfile.write('\n')
                except Exception as e:
                    # print(e)
                    if str(e) == 'timed out':
                        pass
                    else:
                        break
        else:
            while True:
                try:
                    data_recv = conn.recv(nb)
                    decode = dict(zip(variables,
                                      [struct.unpack(r_format, data_recv)]))
                    # print(decode)
                    for chunk in decode.values():
                        value = sum([val for val in chunk])/len(chunk)
                        sys.stdout.write("\033[K")
                        decode_p = dict(zip(variables,
                                            [format(value, '.4f')]))
                        print(('{:^15}'*len(decode_p.values())
                               ).format(*decode_p.values()), end='\r')
                        sys.stdout.flush()
                    test_val.append(decode)
                    if t0 == 0:
                        t0 = time.time()

                    final_time = abs(time.time()-t0)
                except Exception as e:
                    # print(e)
                    if str(e) == 'timed out':
                        pass
                    else:
                        break

    except KeyboardInterrupt:
        try:
            print('\n')
            print('...closing...')
            conn.shutdown(socket.SHUT_RDWR)
            time.sleep(1)
            # Flush error keyboardinterrupt
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            time.sleep(1)
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            print('Done!')
            print('TEST RESULTS ARE:')
            print('TEST DURATION : {} (s)'.format(final_time))
            # # FIND SAMPLING RATE
            # Method 1:
            N_DATA_PACKETS = len(test_val)  # Number of batches received
            print('DATA PACKETS : {} packets'.format(N_DATA_PACKETS))
            # (assuming al batches = buffer_size long)
            Fs = ((N_DATA_PACKETS+1)*BUFFERSIZE/final_time)
            print('SAMPLES PER PACKET : {}'.format(BUFFERSIZE))
            print('VARIABLES PER SAMPLE : {}; {}'.format(
                len(variables), variables))
            print('SIZE OF PACKETS: {} bytes'.format(nb))
            #  32 is batch/buffer size ,
            # so total samples is n_batches (len(vals)) x size_batch
            # print('Period: {} ms ; Fs:{} Hz'.format(
            # timestamp[:].mean()/1e3,1/((timestamp[:].mean())/1e6))
            conn.close()
            print('Period: {} ms ; Fs:{} Hz, Data send rate: {} packets/s of {} samples'.format(
                round((1/Fs)*1e3), round(Fs, -1),
                round(N_DATA_PACKETS/final_time), BUFFERSIZE))
            print(
                'DATA TRANSFER RATE: {} KB/s'.format(round(N_DATA_PACKETS/final_time)*nb/1024))
        except KeyboardInterrupt:
            conn.shutdown(socket.SHUT_RDWR)
            print('...wait for closing...')
            # Flush error keyboardinterrupt
            cmd = '{}.stop_send();gc.collect()'.format(sensorlib)
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                cmd, targ, password)
            cmd_resp = run_command_rl(cmd_str)
            time.sleep(1)
            conn.close()
            print('Done!')


def simple_cmd_r(cmd):
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    resp_info_list = []
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    resp_info_list.append(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    if len(resp_info_list) > 0:
        return resp_info_list[0]


# LOGGING DATETIME NOW:
def lognow(filename, sensor):
    if filename == 'now':
        return 'log_{}_{}.txt'.format(sensor,
                                      datetime.now().strftime("%m_%d_%Y_%H_%M_%S"))
    else:
        return filename


#############################################
def address_entry_point(entry_point, group_file=''):
    if group_file == '':
        group_file = 'UPY_G'
    # print(group_file)
    if '{}.config'.format(group_file) not in os.listdir() or args.g:
        group_file = '{}/{}'.format(upydev.__path__[0], group_file)
    with open('{}.config'.format(group_file), 'r', encoding='utf-8') as group:
        devices = json.loads(group.read())
        # print(devices)
    devs = devices.keys()
    # NAME ENTRY POINT
    if entry_point in devs:
        dev_address = devices[entry_point][0]
        try:
            int(dev_address)
            dev_address = devices[entry_point][1]
        except Exception as e:
            pass
        if '.' in dev_address and dev_address.count('.') == 3:
            # check IP
            try:
                ip_address(dev_address)
                dev_ip = devices[entry_point][0]
                dev_pass = devices[entry_point][1]
                return (dev_ip, dev_pass)
            except Exception as e:
                print(e)
        elif 'COM' in dev_address or '/dev/' in dev_address:
            dev_sport = devices[entry_point][0]
            dev_br = devices[entry_point][1]
            return (dev_sport, dev_br)
        elif len(dev_address.split('-')) == 5:
            try:
                assert [len(s) for s in dev_address.split(
                    '-')] == [8, 4, 4, 4, 12], dev_address
                dev_uuid = devices[entry_point][0]
                dev_pass = devices[entry_point][1]
                return (dev_uuid, dev_pass)
            except Exception as e:
                print('uuid malformed')
        elif ':' in dev_address:
            dev_uuid = devices[entry_point][0]
            dev_pass = devices[entry_point][1]
            return (dev_uuid, dev_pass)
    else:
        print('Device not configured in global group')
        print("Do '$ upydev see -gg' to see devices global group")
        sys.exit()
#############################################


def pytest(devname):
    if args.f is not None:
        test = args.f
    elif args.fre is not None:
        test = ' '.join(args.fre)
    else:
        test = ''
    pytest_cmd_str = 'pytest {} -s --dev {}'.format(test, devname)
    if args.md:
        pytest_cmd_str = ' '.join([pytest_cmd_str, args.md[0]])
    pytest_cmd = shlex.split(pytest_cmd_str)
    old_action = signal.signal(signal.SIGINT, signal.SIG_IGN)

    def preexec_function(action=old_action):
        signal.signal(signal.SIGINT, action)
    try:
        pytest_session = subprocess.call(pytest_cmd, preexec_fn=preexec_function)
        signal.signal(signal.SIGINT, old_action)
    except KeyboardInterrupt:
        pass
        print('')


#############################################

def handle_action(args, exit=True):
    # UPYDEV RAW COMMAND MODE: (WHEN ARGUMENT Mode is not in keyword list)

    if args.m not in keywords_mode:
        cmd = args.m
        dev = Device(args.t, args.p, init=True)
        dev.wr_cmd(cmd, follow=True)
        dev.disconnect()
        if exit:
            sys.exit()

    # FILEIO ACTIONS

    elif args.m in FILEIO_ACTIONS:
        from upydev.fileio import fileio_action
        if vars(args)['@'] is not None:
            dev_name = entryp
        else:
            dev_name = _dev_name
        fileio_action(args, device=dev_name)

    # REPL ACTIONS

    elif args.m in REPL_ACTIONS:
        from upydev.repls import repl_action
        if vars(args)['@'] is not None:
            dev_name = entryp
        else:
            dev_name = _dev_name
        repl_action(args, device=dev_name)

    # FIRMWARE ACTIONS

    elif args.m in FIRMWARE_ACTIONS:
        from upydev.firmwaretools import firmwaretools_action
        if vars(args)['@'] is not None:
            dev_name = entryp
        else:
            dev_name = _dev_name
        firmwaretools_action(args, device=dev_name)

    # DEBUGGING ACTIONS

    elif args.m in DEBUGGING_ACTIONS:
        from upydev.debugging import debugging_action
        if vars(args)['@'] is not None:
            dev_name = entryp
        else:
            dev_name = _dev_name
        debugging_action(args, device=dev_name)

    # KEYGEN ACTIONS
    elif args.m in KEYGEN_ACTIONS:
        from upydev.keygen import keygen_action
        if vars(args)['@'] is not None:
            dev_name = entryp
        else:
            dev_name = _dev_name
        key_dict = keygen_action(args, device=dev_name)
        if key_dict:
            from upydev.fileio import fileio_action
            args.m = 'put'
            if key_dict['mode'] == 'SSL':
                key, cert = key_dict['Files']
                args.fre = [key, cert]
                fileio_action(args, device=dev_name)
                # put_f(args.t, args.p, rst=False)
                # args.f = cert
                # put_f(args.t, args.p, rst=args.rst)
            elif key_dict['mode'] == 'RSA':
                rsa_key, = key_dict['Files']
                args.f = rsa_key
                fileio_action(args, device=dev_name)
        if exit:
            sys.exit()

    # SHELL-REPL ACTIONS

    elif args.m in SHELL_REPL_ACTIONS:
        from upydev.shellrepls import shell_repl_action
        if vars(args)['@'] is not None:
            dev_name = entryp
        else:
            dev_name = _dev_name
        shell_repl_action(args, device=dev_name)

    # * GENERAL COMMANDS *

    elif args.m in GENERAL_COMMANDS:
        from upydev.gencommands import gen_command
        gen_command(args.m, args.t, args.p, f=args.f, s=args.s, wp=args.wp,
                    ap=args.ap, i2c=args.i2c, spi=args.spi, utc=args.utc,
                    init=True, ssl=args.wss, auth=args.wss)

    #############################################
    # WLAN UTILS COMMANDS
    elif args.m in WLAN_UTILS_COMMANDS:
        from upydev.wlancommands import wlan_command
        wlan_command(args.m, args.t, args.p, wp=args.wp, ap=args.ap,
                     init=True, ssl=args.wss, auth=args.wss)

    #############################################

    # SD COMMANDS
    elif args.m in SD_UTILS_COMMANDS:
        from upydev.sdcommands import sd_command
        sd_command(args.m, args.t, args.p, po=args.po,
                   init=True, ssl=args.wss, auth=args.wss)

    #############################################

    # PROTOTYPE COMMANDS
    elif args.m in PROTOTYPE_COMMANDS:
        from upydev.prototypecommands import prototype_command
        prototype_command(args.m, args.t, args.p, wp=args.wp, ap=args.ap,
                          init=True, ssl=args.wss, auth=args.wss)

    #############################################


# keyword live output commands:
kw_loc = ['ping', 'run', 'get', 'put', 'timeit', 'install',
          'see', 'sync', 'wrepl', 'srepl', 'find', 'diagnose', 'd_sync',
          'stream_test', 'log', 'debug', 'gen_rsakey', 'rf_wrkey', 'upy'
          'ssl', 'shr', 'wssl', 'wssrepl', 'jupyterc', 'pytest',
          'pytest-setup', 'ble', 'set']  # implemented till sync in GP
# diagnose in G

# UPYDEVICE CLASS


# class UPYDEVICE:
#     def __init__(self, devname, ip, passwd, command, port=8005):
#         self.name = devname
#         self.ip = ip
#         self.password = passwd
#         self.command = command
#         self.port = port
#         self.dev_process = multiprocessing.Process(
#             target=self.run_command_callback)
#         self.dev_process_raw = multiprocessing.Process(
#             target=self.run_command_raw_callback)
#         self.dev_ping = multiprocessing.Process(target=self.ping_callback)
#         self.dev_run_script = multiprocessing.Process(
#             target=run_script, args=(self.ip, self.password, '{}: '.format(self.name), ))
#         self.dev_timeit_script = multiprocessing.Process(
#             target=timeit_script, args=(self.ip, self.password, '{}: '.format(self.name), ))
#         self.dev_put = multiprocessing.Process(
#             target=put_f, args=(self.ip, self.password, args.rst))
#         self.dev_put_multiple = multiprocessing.Process(
#             target=put_multiple_f, args=(self.ip, self.password))
#         self.dev_install = multiprocessing.Process(target=install_f, args=(
#             self.ip, self.password, '{}: '.format(self.name), ))
#         self.dev_get = multiprocessing.Process(target=get_f, args=(
#             self.ip, self.password, '/{}_{}'.format(self.name, args.f)))
#         self.dev_get_multiple = multiprocessing.Process(
#             target=get_multiple_f, args=(self.ip, self.password, 'device_id', self.name))
#         self.dev_sync = multiprocessing.Process(target=sync, args=(
#             self.ip, self.password, '{}_{}'.format(self.name, args.f), self.port))
#         self.dev_sync_multiple = multiprocessing.Process(target=sync_multiple_f, args=(
#             self.ip, self.password, 'device_id', self.name, self.port))
#
#     def run_command_callback(self):
#         group_cmd_str = 'upydev {} -t {} -p {}'.format(
#             self.command, self.ip, self.password)
#         # print(group_cmd_str)
#         group_cmd = shlex.split(group_cmd_str)
#         try:
#             proc = subprocess.Popen(
#                 group_cmd, stdout=subprocess.PIPE,
#                 stderr=subprocess.STDOUT)
#             while proc.poll() is None:
#                 print('{}:{}'.format(
#                     self.name, proc.stdout.readline()[:-1].decode()))
#         except KeyboardInterrupt:
#             time.sleep(1)
#             result = proc.stdout.readlines()
#             for message in result:
#                 print('{}:{}'.format(self.name, message[:-1].decode()))
#
#     def run_command_raw_callback(self):
#         group_cmd_str = 'web_repl_cmd_r -c {} -t {} -p {} -wt 0.8'.format(
#             self.command, self.ip, self.password)
#         # print(group_cmd_str)
#         group_cmd = shlex.split(group_cmd_str)
#         try:
#             proc = subprocess.Popen(
#                 group_cmd, stdout=subprocess.PIPE,
#                 stderr=subprocess.STDOUT)
#             for i in range(6):
#                 proc.stdout.readline()
#             while proc.poll() is None:
#                 resp = proc.stdout.readline()[:-1].decode()
#                 if len(resp) > 0:
#                     if resp[0] == '>':
#                         print('{}:{}'.format(self.name, resp[4:]))
#                     else:
#                         print('{}:{}'.format(self.name, resp))
#                 else:
#                     print(resp)
#         except KeyboardInterrupt:
#             time.sleep(1)
#             result = proc.stdout.readlines()
#             for message in result:
#                 print('{}:{}'.format(self.name, message[:-1].decode()))
#
#     def ping_callback(self):
#         ping_cmd_str = 'ping {}'.format(self.ip)
#         ping_cmd = shlex.split(ping_cmd_str)
#         try:
#             proc = subprocess.Popen(
#                 ping_cmd, stdout=subprocess.PIPE,
#                 stderr=subprocess.STDOUT)
#             while proc.poll() is None:
#                 print('{}:{}'.format(
#                     self.name, proc.stdout.readline()[:-1].decode()))
#         except KeyboardInterrupt:
#             time.sleep(1)
#             result = proc.stdout.readlines()
#             for message in result:
#                 print('{}:{}'.format(self.name, message[:-1].decode()))
#
#     def run_command(self):
#         self.dev_process.start()
#
#     def run_command_raw(self):
#         self.dev_process_raw.start()
#
#     def ping(self):
#         self.dev_ping.start()
#
#     def run_scrpt(self):
#         self.dev_run_script.start()
#
#     def timeit_scrpt(self):
#         self.dev_timeit_script.start()
#
#     def put_df(self):
#         self.dev_put.start()
#
#     def put_multiple_df(self):
#         self.dev_put_multiple.start()
#
#     def install_df(self):
#         self.dev_install.start()
#
#     def get_df(self):
#         self.dev_get.start()
#
#     def get_multiple_df(self):
#         self.dev_get_multiple.start()
#
#     def sync_df(self):
#         self.dev_sync.start()
#
#     def sync_multiple_df(self):
#         self.dev_sync_multiple.start()


#############################################
# UPYDEV MODES:
# HELP
if args.m == 'h' or args.m == 'help':
    from upydev.helpinfo import HELP_INFO_ARG
    # UPYDEV CHECK VERSION
    try:
        resp = requests.get("https://pypi.org/pypi/%s/json" % ('upydev',), timeout=0.1)
        upydev_versions = resp.json()["releases"].keys()
        latest = version.parse(list(upydev_versions)[-1])
        this_version = version.parse(upydev.version)
        if latest > this_version:
            print('\u001b[33mYou are using upydev {} but a new version {} is available\
 in PyPi\u001b[0m'.format(this_version, latest))
    except Exception as e:
        pass
    print(parser.version)
    print(parser.description, end='\n\n')
    print("usage: " + parser.usage.replace('%(prog)s', upydev.name), end='\n\n')
    print('\n\t'.join(HELP_INFO_ARG.splitlines()).replace('%%', '%'))
    print("\n (Do '$ upydev -h' to see help info about optional arguments too)")
    sys.exit()

if args.m in help_actions:
    if not any([args.m in GENERAL_COMMANDS,
                args.m in WLAN_UTILS_COMMANDS,
                args.m in SD_UTILS_COMMANDS,
                args.m in PROTOTYPE_COMMANDS]):
        if args.m == 'dm':
            from upydev.devicemanagement import DEVICE_MANAGEMENT_HELP
            print(DEVICE_MANAGEMENT_HELP)
            sys.exit()
        elif args.m == 'fio':
            from upydev.fileio import FILEIO_HELP
            print(FILEIO_HELP)
            sys.exit()
        elif args.m == 'fw':
            from upydev.firmwaretools import FIRMWARE_HELP
            print(FIRMWARE_HELP)
            sys.exit()
        elif args.m == 'kg':
            from upydev.keygen import KEYGEN_HELP
            print(KEYGEN_HELP)
            sys.exit()
        elif args.m == 'rp':
            from upydev.repls import REPLS_HELP
            print(REPLS_HELP)
            sys.exit()
        elif args.m == 'sh':
            from upydev.shellrepls import SHELL_REPLS_HELP
            print(SHELL_REPLS_HELP)
            sys.exit()
        elif args.m == 'db':
            from upydev.debugging import DEBUGGING_HELP
            print(DEBUGGING_HELP)
            sys.exit()
        elif args.m == 'gp':
            from upydev.groupmode import GROUP_MODE_HELP
            print(GROUP_MODE_HELP)
            sys.exit()

if args.m not in keywords_mode and args.m.startswith('%'):
    action = args.m.replace('%', '')
    see_help(action)
    sys.exit()

_dev_name = None
# @ ENTRY
if "@" in args.m:
    args.m, entry_point = args.m.split('@')
    args.t, args.p = address_entry_point(entry_point)
    _dev_name = entry_point

# DEVICE MANAGEMENT
if args.m in DEVICE_MANAGEMENT_ACTIONS:
    from upydev.devicemanagement import devicemanagement_action
    devicemanagement_action(args, device=_dev_name)

# UPYDEV LOOKS FOR UPYDEV_.CONFIG FILE
if args.t is None:
    try:
        file_conf = 'upydev_.config'
        if file_conf not in os.listdir() or args.g:
            file_conf = '{}/upydev_.config'.format(upydev.__path__[0])

        with open(file_conf, 'r') as config_file:
            upy_conf = json.loads(config_file.read())
        args.t = upy_conf['ip']
        args.p = upy_conf['passwd']
        if 'name' in upy_conf:
            _dev_name = upy_conf['name']
        else:
            _dev_name = 'upydevice'
        # @ ENTRY POINT
        if args.b is not None:
            if "@" in args.b:
                gf, entryp = args.b.split('@')
                args.t, args.p = address_entry_point(entryp, gf)
        if vars(args)['@'] is not None:
                entryp = vars(args)['@']
                args.t, args.p = address_entry_point(entryp)
        if args.apmd:
            args.t = '192.168.4.1'
        if args.st:
            print('Target:{}'.format(args.t))
    except Exception as e:
        print('upydev_.config file not found, please provide target and \
        password or create config file with command "config"')
        see_help('config')
        sys.exit()

# UPYDEV GROUP COMMAND
if args.m == 'gg':
    args.G = 'UPY_G'
    args.m = 'see'

if args.gg:
    # if args.m not in DEBUGGING_ACTIONS:
        args.G = 'UPY_G'

if args.G is not None:
    try:
        group_file = args.G
        # print(group_file)
        if '{}.config'.format(group_file) not in os.listdir() or args.g:
            group_file = '{}/{}'.format(upydev.__path__[0], args.G)
        # if args.m == 'see':
        #     see()
        #     sys.exit()
        if args.m == 'pytest':
            print('Running pytest in group: {}'.format(group_file.split('/')[-1]))
            with open('{}.config'.format(group_file), 'r', encoding='utf-8') as group:
                devices = json.loads(group.read())
                # print(devices)
            devs = devices.keys()
            if args.devs is not None:
                devs = args.devs
            for dev in devs:
                print('Running pytest with Device: {}'.format(dev))
                pytest(dev)
            sys.exit()

        print('Sending command to group: {}'.format(group_file.split('/')[-1]))
        with open('{}.config'.format(group_file), 'r', encoding='utf-8') as group:
            devices = json.loads(group.read())
            # print(devices)
        devs = devices.keys()
        if args.devs is not None:
            devs = args.devs
        if args.m != 'probe' or args.m != 'scan':
            for dev in devs:
                columns, rows = os.get_terminal_size(0)
                single_command = []
                print('')
                print(''*columns)
                args.t, args.p = address_entry_point(dev, args.G)
                print('Device Name: {}'.format(dev))
                dev_addr = devices[dev][0]
                dev_pass = devices[dev][1]
                dev_type = check_device_type(dev_addr)
                _dev_name = dev
                print('{} @ {}'.format(dev_type, dev_addr))
                print('Sending command {} ...'.format(args.m))

                try:
                    handle_action(args, exit=False)
                except Exception as e:
                    print(e)
        else:
            handle_action(args)

        sys.exit()
    except Exception as e:
        print(e)
        print('file not found, please create a group first')
        sys.exit()


# UPYDEV GROUP COMMAND THREADED MODE:
if args.GP is not None:
    pass
    # try:
    #     group_file = args.GP
    #     # print(group_file)
    #     if '{}.config'.format(group_file) not in os.listdir() or args.g:
    #         group_file = '{}/{}'.format(upydev.__path__[0], args.GP)
    #     print('Sending command to group: {}'.format(group_file.split('/')[-1]))
    #     with open('{}.config'.format(group_file), 'r', encoding='utf-8') as group:
    #         devices = json.loads(group.read())
    #         # print(devices)
    #     devs = devices.keys()
    #     PORTS = [8005+i for i in range(len(devs))]
    #     PORTS_DICT = dict(zip(devs, PORTS))
    #     if args.devs is not None:
    #         devs = args.devs
    #         PORTS = [8005+i for i in range(len(devs))]
    #         PORTS_DICT = dict(zip(devs, PORTS))
    #     for dev in devs:
    #         print('Device Name: {} ; IP: {}'.format(dev, devices[dev][0]))
    #     print('Sending command {} ...'.format(args.m))
    #     # print(sys.argv[1:])
    #     single_command = []
    #     for i in range(len(sys.argv[1:])):
    #         if sys.argv[1:][i] != '-GP':
    #             if i == 0 or sys.argv[1:][i-1] != '-GP':
    #                 if sys.argv[1:][i] not in devs and sys.argv[1:][i] != '-devs':
    #                     single_command.append(sys.argv[1:][i])
    #     gcommand = ' '.join(single_command)
    #     # print(gcommand.split())
    #     # group_cmd_str = 'upydev {} -t {} -p {}'.format(gcommand, dev_ip, dev_pass)
    #     devs_dict = {dev: UPYDEVICE(
    #         dev, devices[dev][0], devices[dev][1], gcommand, PORTS_DICT[dev]) for dev in devs}
    #     if gcommand.split()[0] not in keywords_mode:
    #         devs_dict = {dev: UPYDEVICE(
    #             dev, devices[dev][0], devices[dev][1], '"{};gc.collect()"'.format(gcommand)) for dev in devs}
    #         for dev in devs_dict.keys():
    #             devs_dict[dev].run_command_raw()
    #         try:
    #             while True:
    #                 dev_proc_state = [
    #                     devs_dict[dev].dev_process_raw.is_alive() for dev in devs_dict.keys()]
    #                 if all(state is False for state in dev_proc_state):
    #                     time.sleep(1)
    #                     print('Done!')
    #                     break
    #         except KeyboardInterrupt:
    #             time.sleep(2)
    #             while True:
    #                 dev_proc_state = [
    #                     devs_dict[dev].dev_process_raw.is_alive() for dev in devs_dict.keys()]
    #                 if all(state is False for state in dev_proc_state):
    #                     time.sleep(1)
    #                     for dev in devs_dict.keys():
    #                         devs_dict[dev].dev_process_raw.terminate()
    #                     break
    #
    #     elif gcommand.split()[0] not in kw_loc:
    #         for dev in devs_dict.keys():
    #             devs_dict[dev].run_command()
    #         try:
    #             while True:
    #                 dev_proc_state = [
    #                     devs_dict[dev].dev_process.is_alive() for dev in devs_dict.keys()]
    #                 if all(state is False for state in dev_proc_state):
    #                     time.sleep(1)
    #                     print('Done!')
    #                     break
    #         except KeyboardInterrupt:
    #             time.sleep(2)
    #             while True:
    #                 dev_proc_state = [
    #                     devs_dict[dev].dev_process.is_alive() for dev in devs_dict.keys()]
    #                 if all(state is False for state in dev_proc_state):
    #                     time.sleep(1)
    #                     for dev in devs_dict.keys():
    #                         devs_dict[dev].dev_process.terminate()
    #                     break
    #     else:
    #         # print('Mode not implemented yet')
    #         if gcommand.split()[0] == 'ping':
    #             for dev in devs_dict.keys():
    #                 devs_dict[dev].ping()
    #
    #             try:
    #                 while True:
    #                     time.sleep(0.1)
    #             except KeyboardInterrupt:
    #                 time.sleep(1)
    #                 for dev in devs_dict.keys():
    #                     devs_dict[dev].dev_ping.terminate()
    #
    #         elif gcommand.split()[0] == 'put':
    #             if args.fre is None:
    #                 for dev in devs_dict.keys():
    #                     devs_dict[dev].put_df()
    #             else:
    #                 for dev in devs_dict.keys():
    #                     devs_dict[dev].put_multiple_df()
    #
    #         elif gcommand.split()[0] == 'get':
    #                 if args.fre is None:
    #                     for dev in devs_dict.keys():
    #                         devs_dict[dev].get_df()
    #                 else:
    #                     for dev in devs_dict.keys():
    #                         devs_dict[dev].get_multiple_df()
    #
    #         elif gcommand.split()[0] == 'sync':
    #             if args.fre is None:
    #                 for dev in devs_dict.keys():
    #                     devs_dict[dev].sync_df()
    #             else:
    #                 for dev in devs_dict.keys():
    #                     devs_dict[dev].sync_multiple_df()
    #
    #         elif gcommand.split()[0] == 'install':
    #             for dev in devs_dict.keys():
    #                 devs_dict[dev].install_df()
    #
    #         elif gcommand.split()[0] == 'timeit':
    #             for dev in devs_dict.keys():
    #                 devs_dict[dev].timeit_scrpt()
    #
    #         elif gcommand.split()[0] == 'run':
    #             for dev in devs_dict.keys():
    #                 devs_dict[dev].run_scrpt()
    #
    #             try:
    #                 while True:
    #                     dev_proc_state = [
    #                         devs_dict[dev].dev_run_script.is_alive() for dev in devs_dict.keys()]
    #                     if all(state is False for state in dev_proc_state):
    #                         time.sleep(0.1)
    #                         break
    #             except KeyboardInterrupt:
    #                 time.sleep(2)
    #                 while True:
    #                     dev_proc_state = [
    #                         devs_dict[dev].dev_run_script.is_alive() for dev in devs_dict.keys()]
    #                     if all(state is False for state in dev_proc_state):
    #                         time.sleep(1)
    #                         for dev in devs_dict.keys():
    #                             devs_dict[dev].dev_run_script.terminate()
    #                         break
    #
    #     sys.exit()
    # except Exception as e:
    #     print(e)
    #     print('file not found, please create a group first')
    #     sys.exit()

if args.apmd:
    args.t = '192.168.4.1'

handle_action(args)


#############################################
# SENSOR SPECIFIC COMMANDS

#  * ADC *

# ADC CONFIG
if args.m == 'adc_config':
    if args.att == 'info':
        print(ATTEN_INFO)
    else:
        if args.b is not None:
            print('Available ADC pins for {} board are : {}'.format(
                args.b, ADC_PINS_DICT[args.b]))
        else:
            adc_pin = args.po[0]
            analog_cmd = "from machine import ADC,Pin;analog_pin = ADC(Pin({}));".format(
                adc_pin)
            analog_atten = "analog_pin.atten({});gc.collect()".format(
                ATTEN_DICT[int(args.att)])
            adc_cmd = analog_cmd + analog_atten
            cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
                adc_cmd, args.t, args.p)
            cmd_resp = run_command_rl(cmd_str)
            resp = cmd_resp[1]
            net_info_list = []
            for line in resp[6:]:
                if line == '### closed ###':
                    pass
                else:
                    try:
                        if line[0] == '>':
                            print(line[4:])
                        else:
                            print(line)

                    except Exception as e:
                        if len(line) == 0:
                            pass
                        else:
                            print(e)
                            pass
            print('Pin {} configured as Analog Input with {} attenuation'.format(
                adc_pin, ATTEN_DICT[int(args.att)][4:]))
        sys.exit()

# ADC READ
elif args.m == 'aread':
    analog_read = "((analog_pin.read())/4095)*3.6;gc.collect()"
    adc_cmd = analog_read
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        adc_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    adclev = []
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    adclev.append(line[4:])
                else:
                    adclev.append(line)
            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    if len(adclev) > 0:
        volts = ast.literal_eval(adclev[0])
        print('Volts: {}'.format(volts))
    sys.exit()

# * ADS *
# ADS_INIT
elif args.m == 'ads_init':
    ads_lib = args.ads
    import_ads_cmd = "from {} import {};import init_ADS as ads;".format(
        args.ads, args.ads.upper())
    print('Initialazing ads...')
    ads_init_cmd = "my_ads = ads.MY_ADS({},ads.i2c,None,channel={});".format(
        args.ads.upper(), args.ch)
    if args.i2c != [22, 23]:
        ads_init_cmd = "{};my_ads = ads.MY_ADS({},{},None,channel={});".format(
            'from machine import I2C', args.ads.upper(), 'I2C(scl=Pin({}), sda=Pin({}))'.format(*args.i2c), args.ch)
    ads_final_init = "my_ads.init();gc.collect()"
    ads_init_cmd_str = import_ads_cmd + ads_init_cmd + ads_final_init
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        ads_init_cmd_str, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    net_info_list = []
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    sys.exit()

# ADS_READ
elif args.m == 'ads_read':
    if args.tm is None:
        cmd = "my_ads.read_V();"
        cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
            cmd, args.t, args.p)
        cmd_resp = run_command_rl(cmd_str)
        resp = cmd_resp[1]
        ads_info_list = []
        for line in resp[6:]:
            if line == '### closed ###':
                pass
            else:
                try:
                    if line[0] == '>':
                        ads_info_list.append(line[4:])
                    else:
                        print(line)

                except Exception as e:
                    if len(line) == 0:
                        pass
                    else:
                        print(e)
                        pass
        if len(ads_info_list) > 0:
            my_read = round(ast.literal_eval(ads_info_list[0]), 2)
            print('{} V'.format(my_read))
            if args.f is not None:
                data_shot = [my_read]
                tag_tstamp = datetime.now().strftime("%H:%M:%S")
                time_stamp = tag_tstamp
                if args.n is not None:
                    tag_tstamp = args.n
                data_shot.append(tag_tstamp)
                header = {'VAR': ['V', 'TS'], 'UNIT': 'Volts'}
                if args.f not in os.listdir():
                    with open(args.f, 'w') as file_log:
                        file_log.write(json.dumps(header))
                        file_log.write('\n')
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                else:
                    with open(args.f, 'a') as file_log:
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                print('Logged at {}'.format(time_stamp))

    elif args.ads == 'test':
        stream_ads = "my_ads.start_send(my_ads.chunk_send_V,timeout={})".format(
            args.tm)
        # run_live(stream_acc, args.t, args.p)
        # "imu.stream_acc(soc=cli_soc, timeout={})".format(args.tm)
        fq = 1/(args.tm/1000)
        ch = simple_cmd_r('my_ads.channel')
        print('Streaming ADS: A{} (voltage),fq={}Hz'.format(ch, fq))
        if args.f is not None:
            args.f = lognow(args.f, args.m)
            print('Saving file {} ...'.format(args.f))
            header = {'VAR': ['V'], 'UNIT': 'VOLTS',
                      'fq(hz)': fq}
            with open(args.f, 'w') as file_log:
                file_log.write(json.dumps(header))
                file_log.write('\n')
            test_stream_chunk(stream_ads, args.t, args.p, 'my_ads',
                              filename=args.f, log=True,
                              r_format='f'*20, nb=80, variables=header['VAR'])
        else:
            header = {'VAR': ['V'], 'UNIT': 'VOLTS',
                      'fq(hz)': fq}
            test_stream_chunk(stream_ads, args.t, args.p, 'my_ads',
                              variables=header['VAR'], r_format='f'*20, nb=80)
    else:
        # Do connect
        stream_ads = "my_ads.start_send(my_ads.chunk_send_V,timeout={})".format(
            args.tm)
        # run_live(stream_acc, args.t, args.p)
        # "imu.stream_acc(soc=cli_soc, timeout={})".format(args.tm)
        fq = 1/(args.tm/1000)
        ch = simple_cmd_r('my_ads.channel')
        print('Streaming ADS: A{} (voltage),fq={}Hz'.format(ch, fq))
        if args.f is not None:
            args.f = lognow(args.f, args.m)
            print('Saving file {} ...'.format(args.f))
            header = {'VAR': ['V'], 'UNIT': 'VOLTS',
                      'fq(hz)': fq}
            with open(args.f, 'w') as file_log:
                file_log.write(json.dumps(header))
                file_log.write('\n')
            get_live_stream_chunk(stream_ads, args.t, args.p, 'my_ads',
                                  filename=args.f, log=True,
                                  r_format='f'*20, nb=80, variables=header['VAR'])
        else:
            header = {'VAR': ['V'], 'UNIT': 'VOLTS',
                      'fq(hz)': fq}
            get_live_stream_chunk(stream_ads, args.t, args.p, 'my_ads',
                                  variables=header['VAR'], r_format='f'*20, nb=80)
    sys.exit()
# * IMU *
# IMU_INIT

elif args.m == 'imu_init':
    imu_lib = args.imu
    import_imu_cmd = "from {} import {};import init_IMU as imu;".format(
        args.imu, args.imu.upper())
    print('Initialazing imu...')
    imu_init_cmd = "my_imu = imu.MY_IMU({},imu.i2c,None);".format(
        args.imu.upper())
    if args.i2c != [22, 23]:
        imu_init_cmd = "{};my_imu = imu.MY_IMU({},{},None);".format(
            'from machine import I2C', args.imu.upper(), 'I2C(scl=Pin({}), sda=Pin({}))'.format(*args.i2c))
    imu_final_init = "my_imu.init()"
    imu_init_cmd_str = import_imu_cmd + imu_init_cmd + imu_final_init
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        imu_init_cmd_str, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    net_info_list = []
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    sys.exit()

#  IMUACC

elif args.m == 'imuacc':
    if args.tm is None:
        cmd = "my_imu.read_acc()"
        cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
            cmd, args.t, args.p)
        cmd_resp = run_command_rl(cmd_str)
        resp = cmd_resp[1]
        acc_info_list = []
        for line in resp[6:]:
            if line == '### closed ###':
                pass
            else:
                try:
                    if line[0] == '>':
                        acc_info_list.append(line[4:])
                    else:
                        print(line)

                except Exception as e:
                    if len(line) == 0:
                        pass
                    else:
                        print(e)
                        pass
        if len(acc_info_list) > 0:
            print('X:{},Y:{},Z:{}'.format(*ast.literal_eval(acc_info_list[0])))
            if args.f is not None:
                data_shot = [*ast.literal_eval(acc_info_list[0])]
                tag_tstamp = datetime.now().strftime("%H:%M:%S")
                time_stamp = tag_tstamp
                if args.n is not None:
                    tag_tstamp = args.n
                data_shot.append(tag_tstamp)
                header = {'VAR': ['X', 'Y', 'Z', 'TS'], 'UNIT': 'g=-9.8m/s^2'}
                if args.f not in os.listdir():
                    with open(args.f, 'w') as file_log:
                        file_log.write(json.dumps(header))
                        file_log.write('\n')
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                else:
                    with open(args.f, 'a') as file_log:
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                print('Logged at {}'.format(time_stamp))
    elif args.imu == 'test':
        # Do connect
        stream_acc = "my_imu.start_send(my_imu.sample_send_acc,timeout={})".format(
            args.tm)
        # run_live(stream_acc, args.t, args.p)
        # "imu.stream_acc(soc=cli_soc, timeout={})".format(args.tm)
        fq = 1/(args.tm/1000)
        print('Streaming IMU ACCELEROMETER: X, Y, Z (g=-9.8m/s^2),fq={}Hz'.format(fq))
        if args.f is not None:
            args.f = lognow(args.f, args.m)
            print('Saving file {} ...'.format(args.f))
            header = {'VAR': ['X', 'Y', 'Z'], 'UNIT': 'g=-9.8m/s^2',
                      'fq(hz)': fq}
            with open(args.f, 'w') as file_log:
                file_log.write(json.dumps(header))
                file_log.write('\n')
            test_stream(stream_acc, args.t, args.p, 'my_imu',
                        filename=args.f, log=True, variables=header['VAR'])
        else:
            header = {'VAR': ['X', 'Y', 'Z'], 'UNIT': 'g=-9.8m/s^2',
                      'fq(hz)': fq}
            test_stream(stream_acc, args.t, args.p, 'my_imu',
                        variables=header['VAR'])

    else:
        # Do connect
        stream_acc = "my_imu.start_send(my_imu.sample_send_acc,timeout={})".format(
            args.tm)
        # run_live(stream_acc, args.t, args.p)
        # "imu.stream_acc(soc=cli_soc, timeout={})".format(args.tm)
        fq = 1/(args.tm/1000)
        print('Streaming IMU ACCELEROMETER: X, Y, Z (g=-9.8m/s^2),fq={}Hz'.format(fq))
        if args.f is not None:
            args.f = lognow(args.f, args.m)
            print('Saving file {} ...'.format(args.f))
            header = {'VAR': ['X', 'Y', 'Z'], 'UNIT': 'g=-9.8m/s^2',
                      'fq(hz)': fq}
            with open(args.f, 'w') as file_log:
                file_log.write(json.dumps(header))
                file_log.write('\n')
            get_live_stream(stream_acc, args.t, args.p, 'my_imu',
                            filename=args.f, log=True, variables=header['VAR'])
        else:
            header = {'VAR': ['X', 'Y', 'Z'], 'UNIT': 'g=-9.8m/s^2',
                      'fq(hz)': fq}
            get_live_stream(stream_acc, args.t, args.p, 'my_imu',
                            variables=header['VAR'])

    sys.exit()

# IMUACC SD
elif args.m == 'imuacc_sd':
    # Do connect
    fq = 1/(args.tm/1000)
    header = {'VAR': ['X', 'Y', 'Z'], 'UNIT': 'g=-9.8m/s^2',
              'fq(hz)': fq}
    stream_acc = "my_imu.start_send_SD(my_imu.sample_send_acc_SD,'ACC','{}',timeout={})".format(
        header['UNIT'], args.tm)
    # run_live(stream_acc, args.t, args.p)
    # "imu.stream_acc(soc=cli_soc, timeout={})".format(args.tm)
    print('Streaming IMU ACCELEROMETER: X, Y, Z (g=-9.8m/s^2),fq={}Hz'.format(fq))
    get_live_stream(stream_acc, args.t, args.p, 'my_imu',
                    variables=header['VAR'])
# IMUGY

elif args.m == 'imugy':
    if args.tm is None:
        cmd = "my_imu.read_gy()"
        cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
            cmd, args.t, args.p)
        cmd_resp = run_command_rl(cmd_str)
        resp = cmd_resp[1]
        acc_info_list = []
        for line in resp[6:]:
            if line == '### closed ###':
                pass
            else:
                try:
                    if line[0] == '>':
                        acc_info_list.append(line[4:])
                    else:
                        print(line)

                except Exception as e:
                    if len(line) == 0:
                        pass
                    else:
                        print(e)
                        pass
        if len(acc_info_list) > 0:
            print('X:{},Y:{},Z:{}'.format(*ast.literal_eval(acc_info_list[0])))
            if args.f is not None:
                data_shot = [*ast.literal_eval(acc_info_list[0])]
                tag_tstamp = datetime.now().strftime("%H:%M:%S")
                time_stamp = tag_tstamp
                if args.n is not None:
                    tag_tstamp = args.n
                data_shot.append(tag_tstamp)
                header = {'VAR': ['X', 'Y', 'Z', 'TS'], 'UNIT': 'deg/s'}
                if args.f not in os.listdir():
                    with open(args.f, 'w') as file_log:
                        file_log.write(json.dumps(header))
                        file_log.write('\n')
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                else:
                    with open(args.f, 'a') as file_log:
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                print('Logged at {}'.format(time_stamp))
    else:
        # Do connect
        stream_ = "my_imu.start_send(my_imu.sample_send_gy,timeout={})".format(
            args.tm)
        fq = 1/(args.tm/1000)
        print('Streaming IMU GYRO: X, Y, Z (deg/s),fq={}Hz'.format(fq))
        if args.f is not None:
            args.f = lognow(args.f, args.m)
            print('Saving file {} ...'.format(args.f))
            header = {'VAR': ['X', 'Y', 'Z'], 'UNIT': 'deg/s',
                      'fq(hz)': fq}
            with open(args.f, 'w') as file_log:
                file_log.write(json.dumps(header))
                file_log.write('\n')
            get_live_stream(stream_, args.t, args.p, 'my_imu',
                            filename=args.f, log=True, variables=header['VAR'])
        else:
            header = {'VAR': ['X', 'Y', 'Z'], 'UNIT': 'deg/s',
                      'fq(hz)': fq}
            get_live_stream(stream_, args.t, args.p, 'my_imu',
                            variables=header['VAR'])

    sys.exit()

# IMUMAG

elif args.m == 'imumag':
    if args.tm is None:
        cmd = "my_imu.read_mag()"
        cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
            cmd, args.t, args.p)
        cmd_resp = run_command_rl(cmd_str)
        resp = cmd_resp[1]
        acc_info_list = []
        for line in resp[6:]:
            if line == '### closed ###':
                pass
            else:
                try:
                    if line[0] == '>':
                        acc_info_list.append(line[4:])
                    else:
                        print(line)

                except Exception as e:
                    if len(line) == 0:
                        pass
                    else:
                        print(e)
                        pass
        if len(acc_info_list) > 0:
            print('X:{},Y:{},Z:{}'.format(*ast.literal_eval(acc_info_list[0])))
            if args.f is not None:
                data_shot = [*ast.literal_eval(acc_info_list[0])]
                tag_tstamp = datetime.now().strftime("%H:%M:%S")
                time_stamp = tag_tstamp
                if args.n is not None:
                    tag_tstamp = args.n
                data_shot.append(tag_tstamp)
                header = {'VAR': ['X', 'Y', 'Z', 'TS'], 'UNIT': 'gauss'}
                if args.f not in os.listdir():
                    with open(args.f, 'w') as file_log:
                        file_log.write(json.dumps(header))
                        file_log.write('\n')
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                else:
                    with open(args.f, 'a') as file_log:
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                print('Logged at {}'.format(time_stamp))
    else:
        # Do connect
        stream_ = "my_imu.start_send(my_imu.sample_send_mag,timeout={})".format(
            args.tm)
        # run_live(stream_acc, args.t, args.p)
        # "imu.stream_acc(soc=cli_soc, timeout={})".format(args.tm)
        fq = 1/(args.tm/1000)
        print('Streaming IMU MAGNETOMETER: X, Y, Z (gauss),fq={}Hz'.format(fq))
        if args.f is not None:
            args.f = lognow(args.f, args.m)
            print('Saving file {} ...'.format(args.f))
            header = {'VAR': ['X', 'Y', 'Z'], 'UNIT': 'gauss',
                      'fq(hz)': fq}
            with open(args.f, 'w') as file_log:
                file_log.write(json.dumps(header))
                file_log.write('\n')
            get_live_stream(stream_, args.t, args.p, 'my_imu',
                            filename=args.f, log=True, variables=header['VAR'])
        else:
            header = {'VAR': ['X', 'Y', 'Z'], 'UNIT': 'gauss',
                      'fq(hz)': fq}
            get_live_stream(stream_, args.t, args.p, 'my_imu',
                            variables=header['VAR'])

    sys.exit()

# * BME280 *
# BME_INIT

elif args.m == 'bme_init':
    bme_lib = args.bme
    import_bme_cmd = "from {} import {};import init_BME280 as bme280;".format(
        args.bme, args.bme.upper())
    print('Initialazing bme280...')
    bme_init_cmd = "my_bme = bme280.MY_BME280({},bme280.i2c);".format(
        args.bme.upper())
    if args.i2c != [22, 23]:
        bme_init_cmd = "{};my_bme = bme280.MY_BME280({},{});".format(
            'from machine import I2C', args.bme.upper(), 'I2C(scl=Pin({}), sda=Pin({}))'.format(*args.i2c))
    bme_final_init = "my_bme.init()"
    bme_init_cmd_str = import_bme_cmd + bme_init_cmd + bme_final_init
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        bme_init_cmd_str, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    net_info_list = []
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    sys.exit()

#  BME_READ

elif args.m == 'bme_read':
    if args.tm is None:
        cmd = "my_bme.read_values()"
        cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
            cmd, args.t, args.p)
        cmd_resp = run_command_rl(cmd_str)
        resp = cmd_resp[1]
        bme_info_list = []
        for line in resp[6:]:
            if line == '### closed ###':
                pass
            else:
                try:
                    if line[0] == '>':
                        bme_info_list.append(line[4:])
                    else:
                        print(line)

                except Exception as e:
                    if len(line) == 0:
                        pass
                    else:
                        print(e)
                        pass
        if len(bme_info_list) > 0:
            print('{} C, {} Pa , {} % RH '.format(
                *ast.literal_eval(bme_info_list[0])))
            if args.f is not None:
                data_shot = [*ast.literal_eval(bme_info_list[0])]
                tag_tstamp = datetime.now().strftime("%H:%M:%S")
                time_stamp = tag_tstamp
                if args.n is not None:
                    tag_tstamp = args.n
                data_shot.append(tag_tstamp)
                header = {
                    'VAR': ['Temp(C)', 'Pressure(Pa)', 'RH(%)', 'TS'], 'UNIT': 'T: C; P: Pa; RH: %'}
                if args.f not in os.listdir():
                    with open(args.f, 'w') as file_log:
                        file_log.write(json.dumps(header))
                        file_log.write('\n')
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                else:
                    with open(args.f, 'a') as file_log:
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                print('Logged at {}'.format(time_stamp))
    elif args.bme == 'test':
        # Do connect
        stream_bme = "my_bme.start_send(my_bme.sample_send_data,timeout={})".format(
            args.tm)
        # run_live(stream_acc, args.t, args.p)
        # "imu.stream_acc(soc=cli_soc, timeout={})".format(args.tm)
        fq = 1/(args.tm/1000)
        print('Streaming BME280: Temp (C), Pressure (Pa), Rel. Hummidity (%) ,fq={}Hz'.format(fq))
        if args.f is not None:
            args.f = lognow(args.f, args.m)
            print('Saving file {} ...'.format(args.f))
            header = {'VAR': ['Temp(C)', 'Pressure(Pa)', 'RH(%)', 'TS'], 'UNIT': 'T: C; P: Pa; RH: %',
                      'fq(hz)': fq}
            with open(args.f, 'w') as file_log:
                file_log.write(json.dumps(header))
                file_log.write('\n')
            test_stream(stream_bme, args.t, args.p, 'my_bme',
                        filename=args.f, log=True, variables=header['VAR'])
        else:
            header = {'VAR': ['Temp(C)', 'Pressure(Pa)', 'RH(%)', 'TS'], 'UNIT': 'T: C; P: Pa; RH: %',
                      'fq(hz)': fq}
            test_stream(stream_bme, args.t, args.p, 'my_bme',
                        variables=header['VAR'])

    else:
        # Do connect
        stream_bme = "my_bme.start_send(my_bme.sample_send_data,timeout={})".format(
            args.tm)
        # run_live(stream_acc, args.t, args.p)
        # "imu.stream_acc(soc=cli_soc, timeout={})".format(args.tm)
        fq = 1/(args.tm/1000)
        print('Streaming BME280: Temp (C), Pressure (Pa), Rel. Hummidity (%) ,fq={}Hz'.format(fq))
        if args.f is not None:
            args.f = lognow(args.f, args.m)
            print('Saving file {} ...'.format(args.f))
            header = {'VAR': ['Temp(C)', 'Pressure(Pa)', 'RH(%)'], 'UNIT': 'T: C; P: Pa; RH: %',
                      'fq(hz)': fq}
            with open(args.f, 'w') as file_log:
                file_log.write(json.dumps(header))
                file_log.write('\n')
            get_live_stream(stream_bme, args.t, args.p, 'my_bme',
                            filename=args.f, log=True, variables=header['VAR'])
        else:
            header = {'VAR': ['Temp(C)', 'Pressure(Pa)', 'RH(%)'], 'UNIT': 'T: C; P: Pa; RH: %',
                      'fq(hz)': fq}
            get_live_stream(stream_bme, args.t, args.p, 'my_bme',
                            variables=header['VAR'])

    sys.exit()

# * INA219 *
# INA_INIT

elif args.m == 'ina_init':
    ina_lib = args.ina
    import_ina_cmd = "from {} import {};import init_INA219 as ina219;".format(
        args.ina, args.ina.upper())
    print('Initialazing ina219...')
    ina_init_cmd = "my_ina = ina219.MY_INA219({},ina219.i2c);".format(
        args.ina.upper())
    if args.i2c != [22, 23]:
        ina_init_cmd = "{};my_ina = ina219.MY_INA219({},{});".format(
            'from machine import I2C', args.ina.upper(), 'I2C(scl=Pin({}), sda=Pin({}))'.format(*args.i2c))
    ina_final_init = "my_ina.init()"
    ina_init_cmd_str = import_ina_cmd + ina_init_cmd + ina_final_init
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        ina_init_cmd_str, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    net_info_list = []
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    sys.exit()

#  INA_READ

elif args.m == 'ina_read':
    if args.tm is None:
        cmd = "my_ina.read_values()"
        cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
            cmd, args.t, args.p)
        cmd_resp = run_command_rl(cmd_str)
        resp = cmd_resp[1]
        ina_info_list = []
        for line in resp[6:]:
            if line == '### closed ###':
                pass
            else:
                try:
                    if line[0] == '>':
                        ina_info_list.append(line[4:])
                    else:
                        print(line)

                except Exception as e:
                    if len(line) == 0:
                        pass
                    else:
                        print(e)
                        pass
        if len(ina_info_list) > 0:
            print('{} V, {} mA , {} mW '.format(
                *ast.literal_eval(ina_info_list[0])))
            if args.f is not None:
                data_shot = [*ast.literal_eval(ina_info_list[0])]
                tag_tstamp = datetime.now().strftime("%H:%M:%S")
                time_stamp = tag_tstamp
                if args.n is not None:
                    tag_tstamp = args.n
                data_shot.append(tag_tstamp)
                header = {'VAR': [
                    'Voltage(V)', 'Current(mA)', 'Power(mW)', 'TS'], 'UNIT': 'V: v; C: mA; P: mW'}
                if args.f not in os.listdir():
                    with open(args.f, 'w') as file_log:
                        file_log.write(json.dumps(header))
                        file_log.write('\n')
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                else:
                    with open(args.f, 'a') as file_log:
                        file_log.write(json.dumps(dict(zip(header['VAR'],
                                                           data_shot))))
                        file_log.write('\n')
                print('Logged at {}'.format(time_stamp))
    elif args.ina == 'test':
        # Do connect
        stream_ina = "my_ina.start_send(my_ina.sample_send_data,timeout={})".format(
            args.tm)
        # run_live(stream_acc, args.t, args.p)
        # "imu.stream_acc(soc=cli_soc, timeout={})".format(args.tm)
        fq = 1/(args.tm/1000)
        print('Streaming ina219: Volts (V), Current (mA), Power (mW) ,fq={}Hz'.format(fq))
        if args.f is not None:
            args.f = lognow(args.f, args.m)
            print('Saving file {} ...'.format(args.f))
            header = {'VAR': ['Voltage(V)', 'Current(mA)', 'Power(mW)'], 'UNIT': 'V: v; C: mA; P: mW',
                      'fq(hz)': fq}
            with open(args.f, 'w') as file_log:
                file_log.write(json.dumps(header))
                file_log.write('\n')
            test_stream(stream_ina, args.t, args.p, 'my_ina',
                        filename=args.f, log=True, variables=header['VAR'])
        else:
            header = {'VAR': ['Voltage(V)', 'Current(mA)', 'Power(mW)'], 'UNIT': 'V: v; C: mA; P: mW',
                      'fq(hz)': fq}
            test_stream(stream_ina, args.t, args.p, 'my_ina',
                        variables=header['VAR'])

    else:
        # Do connect
        stream_ina = "my_ina.start_send(my_ina.sample_send_data,timeout={})".format(
            args.tm)
        # run_live(stream_acc, args.t, args.p)
        # "imu.stream_acc(soc=cli_soc, timeout={})".format(args.tm)
        fq = 1/(args.tm/1000)
        print('Streaming ina219: Volts (V), Current (mA), Power (mW) ,fq={}Hz'.format(fq))
        if args.f is not None:
            args.f = lognow(args.f, args.m)
            print('Saving file {} ...'.format(args.f))
            header = {'VAR': ['Voltage(V)', 'Current(mA)', 'Power(mW)'], 'UNIT': 'V: v; C: mA; P: mW',
                      'fq(hz)': fq}
            with open(args.f, 'w') as file_log:
                file_log.write(json.dumps(header))
                file_log.write('\n')
            get_live_stream(stream_ina, args.t, args.p, 'my_ina',
                            filename=args.f, log=True, variables=header['VAR'])
        else:
            header = {'VAR': ['Voltage(V)', 'Current(mA)', 'Power(mW)'], 'UNIT': 'V: v; C: mA; P: mW',
                      'fq(hz)': fq}
            get_live_stream(stream_ina, args.t, args.p, 'my_ina',
                            variables=header['VAR'])

    sys.exit()

# INA_BATT
elif args.m == 'ina_batt':
    print('\n')
    print(' {:>15}'.format('Battery Life expectancy profiling... '))
    cmd = "my_ina.batt_ts_raw()"
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    ina_info_list = []
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    ina_info_list.append(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    if len(ina_info_list) > 0:
        result_dict = json.loads(ast.literal_eval(ina_info_list[0]))
        volts_v, current_v, power_v = result_dict['V'], result_dict['C'], result_dict['P']
        volts = sum(volts_v)/len(volts_v)
        current = sum(current_v)/len(current_v)
        power = sum(power_v)/len(power_v)
        print('\n')
        print('{0:^15} {1:^15}'.format(
            '', '{}  {:>15}  {:>15}'.format('VOLTAGE', 'CURRENT', 'POWER')))
        print('  {0:>15}'.format('='*60))
        print('{0:^15} {1:^15}'.format('| Average |',
                                       '{:.2f} V {:>15.2f} mA  {:>15.2f} mW '.format(volts, current, power)))
        print('{0:^15}'.format('-'*len('| Average |')))
        print('{0:^15} {1:^15}'.format('|   MAX   |', '{:.2f} V {:>15.2f} mA  {:>15.2f} mW '.format(
            max(volts_v), max(current_v), max(power_v))))
        print('{0:^15}'.format('-'*len('| Average |')))
        print('{0:^15} {1:^15}'.format('|   MIN   |', '{:.2f} V {:>15.2f} mA  {:>15.2f} mW '.format(
            min(volts_v), min(current_v), min(power_v))))
        print('{0:^15}'.format('-'*len('| Average |')))
        print('\n')
        if current > 0:
            state = 'Discharging'
        else:
            state = 'Charging'
        percentage = round((volts-3.3)/(4.23-3.4)*100, 1)
        batt_le_full = (args.batt[0]/current)*0.70
        batt_le_now = round((batt_le_full * percentage)/100, 2)
        header = ' | {0:^15} | {1:^15} | {2:^15} | {3:^15} | {4:^20}  |'.format(
            'CAPACITY (mAh)', 'VOLTAGE (V)', 'LEVEL (%)', 'STATE', 'TIME LEFT (Hours)')
        print('  {0:^15}   {1:^15}   {2:^15}   {3:^15}   {4:^20}  '.format(
            '', '', 'BATTERY INFO', '', ''))
        print(' {0:>15}'.format('='*(len(header)-1)))
        print(header)
        print(' {0:>15}'.format('-'*(len(header)-1)))
        # print('| {0:^15} | {1:^15} | {2:^15} | {3:^15} | {4:^20} |'.format('', '', '', '', ''))
        print(' | {0:^15} | {1:^15.2f} | {2:^15} | {3:^15} | {4:^20}  |'.format(
            args.batt[0], volts, percentage, state, batt_le_now))
        # print('| {0:^15} | {1:^15} | {2:^15} | {3:^15} | {4:^20} |'.format('', '', '', '', ''))
        # print(' {0:>15}'.format('='*len(header)))
        print('\n')
        # if args.f is not None:
        #     data_shot = [*ast.literal_eval(ina_info_list[0])]
        #     tag_tstamp = datetime.now().strftime("%H:%M:%S")
        #     time_stamp = tag_tstamp
        #     if args.n is not None:
        #         tag_tstamp = args.n
        #     data_shot.append(tag_tstamp)
        #     header = {'VAR': ['Voltage(V)', 'Current(mA)', 'Power(mW)', 'TS'], 'UNIT': 'V: v; C: mA; P: mW'}
        #     if args.f not in os.listdir():
        #         with open(args.f, 'w') as file_log:
        #             file_log.write(json.dumps(header))
        #             file_log.write('\n')
        #             file_log.write(json.dumps(dict(zip(header['VAR'],
        #                                                data_shot))))
        #             file_log.write('\n')
        #     else:
        #         with open(args.f, 'a') as file_log:
        #             file_log.write(json.dumps(dict(zip(header['VAR'],
        #                                                data_shot))))
        #             file_log.write('\n')
        #     print('Logged at {}'.format(time_stamp))
#############################################
# * DAC *

# DAC CONFIG
elif args.m == 'dac_config':
    if args.b is not None:
        print('Available DAC pins for {} board are : {}'.format(
            args.b, ADC_PINS_DICT[args.b]))
    else:
        dac_pin = args.po[0]
        analog_cmd = "from machine import DAC;analogdac_pin = DAC(Pin({}));".format(
            dac_pin)
        dac_cmd = analog_cmd
        cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
            dac_cmd, args.t, args.p)
        cmd_resp = run_command_rl(cmd_str)
        resp = cmd_resp[1]
        for line in resp[6:]:
            if line == '### closed ###':
                pass
            else:
                try:
                    if line[0] == '>':
                        print(line[4:])
                    else:
                        print(line)

                except Exception as e:
                    if len(line) == 0:
                        pass
                    else:
                        print(e)
                        pass
        print('Pin {} configured as Analog Output'.format(
            dac_pin))
    sys.exit()

# DAC WRITE ## 8 BITS, 0-255
elif args.m == 'dac_write':
    val_from_v = int((float(args.sig[0])/3.3)*255)
    analog_write = "analogdac_pin.write({});gc.collect()".format(val_from_v)
    dac_cmd = analog_write
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        dac_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)
            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    sys.exit()


# DAC_SIG

elif args.m == 'dac_sig':
    cmds = ['start', 'stop', 'mod']
    if args.sig[0] not in cmds:
        signal_class = "from dac_signal_gen import SIGNAL_GENERATOR;"
        signal_cmd = "sig=SIGNAL_GENERATOR(analogdac_pin,'{}',{},{})".format(
            *args.sig)
        conf_dac_sig = signal_class + signal_cmd
        cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
            conf_dac_sig, args.t, args.p)
        cmd_resp = run_command_rl(cmd_str)
        resp = cmd_resp[1]
        for line in resp[6:]:
            if line == '### closed ###':
                pass
            else:
                try:
                    if line[0] == '>':
                        print(line[4:])
                    else:
                        print(line)
                except Exception as e:
                    if len(line) == 0:
                        pass
                    else:
                        print(e)
                        pass
        print('Signal type {} with Amplitude {} V and fq {} Hz configured'.format(
            *args.sig))
    elif args.sig[0] == cmds[0]:
        signal_cmd = "sig.start()"
        cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
            signal_cmd, args.t, args.p)
        cmd_resp = run_command_rl(cmd_str)
        resp = cmd_resp[1]
        for line in resp[6:]:
            if line == '### closed ###':
                pass
            else:
                try:
                    if line[0] == '>':
                        print(line[4:])
                    else:
                        print(line)
                except Exception as e:
                    if len(line) == 0:
                        pass
                    else:
                        print(e)
                        pass
        print('Signal started!')

    elif args.sig[0] == cmds[1]:
        signal_cmd = "sig.stop()"
        cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
            signal_cmd, args.t, args.p)
        cmd_resp = run_command_rl(cmd_str)
        resp = cmd_resp[1]
        for line in resp[6:]:
            if line == '### closed ###':
                pass
            else:
                try:
                    if line[0] == '>':
                        print(line[4:])
                    else:
                        print(line)
                except Exception as e:
                    if len(line) == 0:
                        pass
                    else:
                        print(e)
                        pass
        print('Signal stopped!')

    elif args.sig[0] == cmds[2]:
        signal_cmd = "sig.modsig({},{})".format(args.sig[1], args.sig[2])
        cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
            signal_cmd, args.t, args.p)
        cmd_resp = run_command_rl(cmd_str)
        resp = cmd_resp[1]
        for line in resp[6:]:
            if line == '### closed ###':
                pass
            else:
                try:
                    if line[0] == '>':
                        print(line[4:])
                    else:
                        print(line)
                except Exception as e:
                    if len(line) == 0:
                        pass
                    else:
                        print(e)
                        pass
        print('Signal modified to Amplitude: {} V, fq: {} Hz'.format(
            args.sig[1], args.sig[2]))

    sys.exit()

#############################################
# * BUZZER *
# BUZZ CONFIG
elif args.m == 'buzz_config':
    BUZZ_pin = args.po[0]
    buzz_cmd = "from buzzertools import BUZZER;my_buzz = BUZZER({});".format(
        BUZZ_pin)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        buzz_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('Pin {} configured as PWM to drive the buzzer'.format(
        BUZZ_pin))
    sys.exit()

# BUZZ SET_ALARM
elif args.m == 'buzz_set_alarm':
    if len(args.at) < 3:
        hour, minute = args.at
        seconds = 0
    else:
        hour, minute, seconds = args.at
    buzz_cmd = "my_buzz.set_alarm_at({},{},{});".format(hour, minute, seconds)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        buzz_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('Alarm set at {}:{}:{}'.format(hour, minute, seconds))
    sys.exit()

# BUZZ INTERRUPT
elif args.m == 'buzz_interrupt':
    buzz_cmd = "my_buzz.active_button({},{});".format(*args.po)
    if args.md is not None:
        if args.md[0] == 'rev':
            buzz_cmd = "my_buzz.active_button_rev({},{});".format(*args.po)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        buzz_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('Button interrupt set at Pins; {},{}'.format(*args.po))
    sys.exit()

# BUZZ BEEP
elif args.m == 'buzz_beep':
    buzz_cmd = "my_buzz.buzz_beep({},{},{},{});".format(*args.opt)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        buzz_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('Beep! '*args.opt[1])
    sys.exit()

#############################################
#  * MOTORS *

#  * SERVO *
# SERVO_CONFIG
elif args.m == 'servo_config':
    servo_pin = args.po[0]
    servo_cmd = "from servo import Servo;my_servo = Servo(Pin({}));".format(
        servo_pin)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        servo_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('Pin {} configured as PWM to drive the Servo motor'.format(
        servo_pin))
    sys.exit()

elif args.m == 'servo_angle':
    servo_angle = args.opt[0]
    servo_cmd = "my_servo.write_angle({});".format(
        servo_angle)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        servo_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('Servo moved to {} degrees!'.format(
        servo_angle))
    sys.exit()


# * DC MOTOR *

# DCMOTOR_CONFIG

elif args.m == 'dcmotor_config':
    dir_pin, oppo_pin = args.po
    dcmotor_cmd = "from dcmotor import DCMOTOR;my_dcmotor = DCMOTOR({},{});".format(
        dir_pin, oppo_pin)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        dcmotor_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('DC motor configured: Direction Pin:{}, Opposite direction Pin: {}'.format(
        dir_pin, oppo_pin))
    sys.exit()

# DCMOTOR_MOVE
elif args.m == 'dcmotor_move':
    dcmotor_dir_dic = {'R': 0, 'L': 1}
    dcmotor_direction, velocity = args.to
    dcmotor_cmd = "my_dcmotor.move({},{});".format(
        dcmotor_dir_dic[dcmotor_direction], velocity)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        dcmotor_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('DC motor moving to {}!'.format(dcmotor_direction))
    sys.exit()

# DCMOTOR_STOP
elif args.m == 'dcmotor_stop':
    dcmotor_cmd = "my_dcmotor.stop();"
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        dcmotor_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('DC motor stopped')
    sys.exit()
# * STEPPER MOTOR *

# STEPPER_CONFIG

elif args.m == 'stepper_config':
    dir_pin, step_pin = args.po
    stepper_cmd = "from stepper import STEPPER;my_stepper = STEPPER({},{});".format(
        dir_pin, step_pin)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        stepper_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('Stepper motor configured: Direction Pin:{}, Step Pin: {}'.format(
        dir_pin, step_pin))
    sys.exit()

# STEPPER_MOVE

elif args.m == 'stepper_move':
    step_dir_dic = {'R': 0, 'L': 1}
    step_direction, velocity, steps = args.to
    stepper_cmd = "my_stepper.move_n_steps({},{},{});".format(
        step_dir_dic[step_direction], velocity, steps)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        stepper_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('Stepper moved {} steps to {} !'.format(
        steps, step_direction))
    sys.exit()


#############################################
#  * NETWORKING *

#  * MQTT *

# MQTT_CONFIG

elif args.m == 'mqtt_config':
    if len(args.client) < 4:
        id, b_addr = args.client
        client_cmd = "from mqtt_client import mqtt_client ;my_mqtt = mqtt_client('{}','{}');".format(
            id, b_addr)
    else:
        id, b_addr, user, passwd = args.client
        client_cmd = "from mqtt_client import mqtt_client ;my_mqtt = mqtt_client('{}','{}',user = '{}', password = '{}');".format(
            id, b_addr, user, passwd)

    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        client_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('MQTT Client configured: ID: {}, BROKER: {}'.format(
        id, b_addr))
    sys.exit()

# MQTT_CONN
elif args.m == 'mqtt_conn':
    conn_cmd = "my_mqtt.connect();my_mqtt.set_def_callback();gc.collect()"
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        conn_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('MQTT Client connected!')
    sys.exit()

# MQTT_SUB
elif args.m == 'mqtt_sub':
    sub_cmd = "my_mqtt.subs('{}');gc.collect()".format(*args.to)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        sub_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    print('MQTT Client subscribed to TOPIC: {}'.format(*args.to))
    sys.exit()

# MQTT_PUB
elif args.m == 'mqtt_pub':
    if len(args.to) > 1:
        pub_cmd = "my_mqtt.pub(topic='{}',paylod='{}');gc.collect()".format(
            *args.to)
    else:
        pub_cmd = "my_mqtt.pub('{}');gc.collect()".format(*args.to)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        pub_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    if len(args.to) > 1:
        print('MQTT Client published message: {} to TOPIC: {}'.format(*args.to))
    else:
        print('MQTT Client published the message: {}'.format(*args.to))
    sys.exit()

# MQTT_CHECK

elif args.m == 'mqtt_check':
    check_cmd = "my_mqtt.check_msg();gc.collect()"
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        check_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    print(line[4:])
                else:
                    print(line)

            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    sys.exit()

# * SOCKETS *

# SOCLI_INIT
elif args.m == 'socli_init':
    if len(args.server) > 2:
        host, port, buff = args.server
        socli_init_cmd = "my_cli=socket_client('{}',{},{})".format(
            host, port, buff)
    else:
        host, port = args.server
        socli_init_cmd = "my_cli=socket_client('{}',{})".format(host, port)
    socli_imp_cmd = "from socket_client_server import socket_client;"
    socli_comp_cmd = '{}{}'.format(socli_imp_cmd, socli_init_cmd)
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        socli_comp_cmd, args.t, args.p)
    run_live_cmd = shlex.split(run_cmd_str)
    try:
        proc = subprocess.Popen(
            run_live_cmd, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        for i in range(6):
            proc.stdout.readline()
        while proc.poll() is None:
            resp = proc.stdout.readline()[:-1].decode()
            if len(resp) > 0:
                if resp[0] == '>':
                    print(resp[4:])
                else:
                    print(resp)
            else:
                print(resp)
    except Exception as e:
        print(e)

    print('Initialized client socket to connect to server :{} on port {}'.format(host, port))
    sys.exit()

# SOCLI_CONN
elif args.m == 'socli_conn':
    socli_conn_cmd = "my_cli.connect_SOC();"
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        socli_conn_cmd, args.t, args.p)
    run_live_cmd = shlex.split(run_cmd_str)
    try:
        proc = subprocess.Popen(
            run_live_cmd, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        for i in range(6):
            proc.stdout.readline()
        while proc.poll() is None:
            resp = proc.stdout.readline()[:-1].decode()
            if len(resp) > 0:
                if resp[0] == '>':
                    print(resp[4:])
                else:
                    print(resp)
            else:
                print(resp)
    except Exception as e:
        print(e)

    print('Client connected!')
    sys.exit()

# SOCLI_SEND
elif args.m == 'socli_send':
    socli_send_cmd = "my_cli.send_message('{}');".format(args.n)
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        socli_send_cmd, args.t, args.p)
    run_live_cmd = shlex.split(run_cmd_str)
    try:
        proc = subprocess.Popen(
            run_live_cmd, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        for i in range(6):
            proc.stdout.readline()
        while proc.poll() is None:
            resp = proc.stdout.readline()[:-1].decode()
            if len(resp) > 0:
                if resp[0] == '>':
                    print(resp[4:])
                else:
                    print(resp)
            else:
                print(resp)
    except Exception as e:
        print(e)

    print('Message sent!')
    sys.exit()

# SOCLI_RECV
elif args.m == 'socli_recv':
    socli_recv_cmd = "my_cli.recv_message();"
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        socli_recv_cmd, args.t, args.p)
    run_live_cmd = shlex.split(run_cmd_str)
    try:
        proc = subprocess.Popen(
            run_live_cmd, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        for i in range(6):
            proc.stdout.readline()
        while proc.poll() is None:
            resp = proc.stdout.readline()[:-1].decode()
            if len(resp) > 0:
                if resp[0] == '>':
                    print(resp[4:])
                else:
                    print(resp)
            else:
                print(resp)
    except Exception as e:
        print(e)

    sys.exit()

# SOCLI_CLOSE
elif args.m == 'socli_close':
    socli_close_cmd = "my_cli.cli_soc.close();"
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        socli_close_cmd, args.t, args.p)
    run_live_cmd = shlex.split(run_cmd_str)
    try:
        proc = subprocess.Popen(
            run_live_cmd, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        for i in range(6):
            proc.stdout.readline()
        while proc.poll() is None:
            resp = proc.stdout.readline()[:-1].decode()
            if len(resp) > 0:
                if resp[0] == '>':
                    print(resp[4:])
                else:
                    print(resp)
            else:
                print(resp)
    except Exception as e:
        print(e)

    print('Client Socket closed!')
    sys.exit()

# SOSRV_INIT
elif args.m == 'sosrv_init':
    if len(args.server) > 1:
        port, buff = args.server
        sosrv_init_cmd = "my_serv=socket_server({},{})".format(port, buff)
    else:
        port = args.server[0]
        sosrv_init_cmd = "my_serv=socket_server({})".format(port)
    sosrv_imp_cmd = "from socket_client_server import socket_server;"
    sosrv_comp_cmd = '{}{}'.format(sosrv_imp_cmd, sosrv_init_cmd)
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        sosrv_comp_cmd, args.t, args.p)
    cmd_resp = run_command_rl(run_cmd_str)
    resp = cmd_resp[1]
    serv_info = []
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    serv_info.append(line[4:])
                else:
                    serv_info.append(line)
            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    if len(serv_info) > 0:
        print('Server initialized. IP: {} PORT:{}'.format(serv_info[0], port))
    sys.exit()

# SOSRV_START
elif args.m == 'sosrv_start':
    sosrv_start_cmd = "my_serv.start_SOC();"
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        sosrv_start_cmd, args.t, args.p)
    run_live_cmd = shlex.split(run_cmd_str)
    try:
        proc = subprocess.Popen(
            run_live_cmd, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        for i in range(6):
            proc.stdout.readline()
        while proc.poll() is None:
            resp = proc.stdout.readline()[:-1].decode()
            if len(resp) > 0:
                if resp[0] == '>':
                    print(resp[4:])
                else:
                    print(resp)
            else:
                print(resp)
    except Exception as e:
        print(e)

    sys.exit()

# SOSRV_SEND
elif args.m == 'sosrv_send':
    sosrv_send_cmd = "my_serv.send_message('{}');".format(args.n)
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        sosrv_send_cmd, args.t, args.p)
    run_live_cmd = shlex.split(run_cmd_str)
    try:
        proc = subprocess.Popen(
            run_live_cmd, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        for i in range(6):
            proc.stdout.readline()
        while proc.poll() is None:
            resp = proc.stdout.readline()[:-1].decode()
            if len(resp) > 0:
                if resp[0] == '>':
                    print(resp[4:])
                else:
                    print(resp)
            else:
                print(resp)
    except Exception as e:
        print(e)

    print('Message sent!')
    sys.exit()

# SOSRV_RECV
elif args.m == 'sosrv_recv':
    sosrv_recv_cmd = "my_serv.recv_message();"
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        sosrv_recv_cmd, args.t, args.p)
    run_live_cmd = shlex.split(run_cmd_str)
    try:
        proc = subprocess.Popen(
            run_live_cmd, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        for i in range(6):
            proc.stdout.readline()
        while proc.poll() is None:
            resp = proc.stdout.readline()[:-1].decode()
            if len(resp) > 0:
                if resp[0] == '>':
                    print(resp[4:])
                else:
                    print(resp)
            else:
                print(resp)
    except Exception as e:
        print(e)

    sys.exit()

# SOSRV_CLOSE
elif args.m == 'sosrv_close':
    sosrv_close_cmd = "my_serv.serv_soc.close();"
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        sosrv_close_cmd, args.t, args.p)
    run_live_cmd = shlex.split(run_cmd_str)
    try:
        proc = subprocess.Popen(
            run_live_cmd, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        for i in range(6):
            proc.stdout.readline()
        while proc.poll() is None:
            resp = proc.stdout.readline()[:-1].decode()
            if len(resp) > 0:
                if resp[0] == '>':
                    print(resp[4:])
                else:
                    print(resp)
            else:
                print(resp)
    except Exception as e:
        print(e)

    print('Server Socket closed!')
    sys.exit()

# * REQUEST *
# RGET_JSON
elif args.m == 'rget_json':
    rq_import_cmd = "import urequests as requests;"
    rq_query_cmd = "resp=requests.get('{}');".format(args.f)
    rq_json_cmd = "resp.json()"
    rq_comp_cmd = "{}{}{}".format(rq_import_cmd, rq_query_cmd, rq_json_cmd)
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        rq_comp_cmd, args.t, args.p)
    run_live_cmd = shlex.split(run_cmd_str)
    try:
        proc = subprocess.Popen(
            run_live_cmd, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        for i in range(6):
            proc.stdout.readline()
        while proc.poll() is None:
            resp = proc.stdout.readline()[:-1].decode()
            if len(resp) > 0:
                if resp[0] == '>':
                    print(resp[4:])
                else:
                    print(resp)
            else:
                print(resp)
    except Exception as e:
        print(e)

    sys.exit()

# RGET_TEXT
elif args.m == 'rget_text':
    rq_import_cmd = "import urequests as requests;"
    rq_query_cmd = "resp=requests.get('{}');".format(args.f)
    rq_text_cmd = "resp.text"
    rq_comp_cmd = "{}{}{}".format(rq_import_cmd, rq_query_cmd, rq_text_cmd)
    run_cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        rq_comp_cmd, args.t, args.p)
    run_live_cmd = shlex.split(run_cmd_str)
    try:
        proc = subprocess.Popen(
            run_live_cmd, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        for i in range(6):
            proc.stdout.readline()
        while proc.poll() is None:
            resp = proc.stdout.readline()[:-1].decode()
            if len(resp) > 0:
                if resp[0] == '>':
                    print(resp[4:])
                else:
                    print(resp)
            else:
                print(resp)
    except Exception as e:
        print(e)

    sys.exit()
#############################################
#  * PORT SPECIFIC COMMANDS *

# BATTERY

elif args.m == 'battery':
    batt_cmd = "from machine import ADC;bat = ADC(Pin(35));bat.atten(ADC.ATTN_11DB);((bat.read()*2)/4095)*3.6;gc.collect()"
    info_cmd = 'import uos;uos.uname();gc.collect()'

    wsdevice = BASE_WS_DEVICE(args.t, args.p, init=True, ssl=args.wss,
                              auth=args.wss)
    batlev = wsdevice.wr_cmd(batt_cmd, silent=True, rtn_resp=True)
    wsdevice.close_wconn()
    try:
        if batlev > 0:
            volts = batlev
            percentage = round((volts - 3.3) / (4.23 - 3.3) * 100, 1)
            print('Battery Voltage : {} V; Level:{} %'.format(
                round(volts, 2), percentage))
    except Exception as e:
        print('Battery Voltage : ? V; Level:? %')
    sys.exit()

# SPECS REF

elif args.m == 'specs':
    try:
        board = args.b
        file_board = '{}/{}.config'.format(upydev.__path__[0], board)
        with open(file_board, 'r') as esp32ref:
            ref_dict = json.loads(esp32ref.read())

        print(ref_dict['SPECS'])

    except Exception as e:
        print("""reference board file not found""")
        sys.exit()

# PIN OUT REF

elif args.m == 'pinout':
    try:
        board = args.b
        file_board = '{}/{}.config'.format(upydev.__path__[0], board)
        with open(file_board, 'r') as esp32ref:
            ref_dict = json.loads(esp32ref.read())

        if args.po is not None:
            pin_query = args.po
            for query in pin_query:
                print('PIN: {}: {}'.format(
                    query, ref_dict['PINOUT'][str(query)]))
        else:
            for key in ref_dict['PINOUT']:
                print('PIN: {}: {}'.format(key, ref_dict['PINOUT'][key]))

    except Exception as e:
        print(str(e), ' Pin not Found or')
        print("""reference board file not found""")
        sys.exit()

    sys.exit()

elif args.m == 'pin_status':
    pinlist = "[16, 17, 26, 25, 34, 39, 36, 4, 21, 13, 12, 27, 33, 15, 32, 14, 22, 23, 5, 18, 19]"
    machine_pin = "pins=[machine.Pin(i, machine.Pin.IN) for i in pin_list]"
    status = "dict(zip([str(p) for p in pins],[p.value() for p in pins]))"
    pin_status_cmd = "import machine;pin_list={};{};{};gc.collect()".format(
        pinlist, machine_pin, status)
    cmd_str = 'web_repl_cmd_r -c "{}" -t {} -p {}'.format(
        pin_status_cmd, args.t, args.p)
    cmd_resp = run_command_rl(cmd_str)
    resp = cmd_resp[1]
    pin_status_resp = []
    for line in resp[6:]:
        if line == '### closed ###':
            pass
        else:
            try:
                if line[0] == '>':
                    pin_status_resp.append(line[4:])
                else:
                    pin_status_resp.append(line)
            except Exception as e:
                if len(line) == 0:
                    pass
                else:
                    print(e)
                    pass
    if len(pin_status_resp) > 0:
        pin_dict = ast.literal_eval(pin_status_resp[0])
        if args.po is not None:
            pin_rqst = ['Pin({})'.format(po) for po in args.po]
            for key in pin_dict.keys():
                if key in pin_rqst:
                    if pin_dict[key] == 1:
                        print('{0:^10} | {1:^5} | HIGH'.format(
                            key, pin_dict[key]))
                    else:
                        print('{0:^10} | {1:^5} |'.format(key, pin_dict[key]))

        else:
            for key in pin_dict.keys():
                if pin_dict[key] == 1:
                    print('{0:^10} | {1:^5} | HIGH'.format(key, pin_dict[key]))
                else:
                    print('{0:^10} | {1:^5} |'.format(key, pin_dict[key]))

    sys.exit()

############################################
