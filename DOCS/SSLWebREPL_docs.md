# SSLWebREPL

### Steps to enable encryption mode:

1. **Put 'ssl_repl.py' in the device**: to do this use '**update_upyutils**' command as:

   `$ upydev update_upyutils` or `$ upydev update_upyutils -@ esp_room1` (if already configurated in the global group ) 

   This will upload : 

   * sync_tool.py
   * upylog.py
   * upynotify.py
   * uping.py
   * upysecrets.py (to enable random WebREPL passwords generation)
   * upysh2.py (to enable 'tree'  and 'du' command)
   * ssl_repl.py (to enable SSLWebREPL)

2. **Generate ECDSA private key and self-signed certificate**  then **upload it to the device**:

   **This needs openssl to be installed/available at $PATH**

   To generate the key do:

   `$ upydev sslgen_key -tfkey` 

   *-tfkey* option is to send the key to the device (so use this if connected directly to the AP of the device or a "secure" wifi e.g. local/home) If not connected to a "secure" wifi upload the key (it is stored in upydev.\__path__) by USB/Serial connection.

   This will ask to set a passphrase, **Do not forget it because it will be needed to log into ssl_wrepl**

   The second time that ask for the passphrase is to convert the key and certificate to .DER format and send it to the device

After these two steps encryption mode is now available:

`$ upydev ssl_wrepl` 

Or if there is already a global "UPY_G" named group, any device can be accessed with this mode using:

e.g.:

`$ upydev ssl@esp_room1`  or `$ upydev ssl@192.168.1.42` 

```bash
mbp@cgg:~$ upydev ssl@esp_room1
Enter passphrase for key 'SSL_key30aea4233564.pem':
SSLWebREPL TLSv1.2 connected
TLSv1.2 @ ECDHE-ECDSA-AES128-CCM8 - 128 bits Encryption

MicroPython v1.12-5-g42e45bd69 on 2019-12-27; ESP32 module with ESP32
Type "help()" for more information.

Use CTRL-x to exit, Use CTRL-s,ENTER to toggle shell/repl mode
Use CTRL-k to see more info
esp32@esp_room1:~ $
```



### SSLWebREPL protocol: 

#### TLSv1.2 @ ECDHE-ECDSA-AES128-CCM8 - 128 bits Encryption

* **Cipher (ECDHE-ECDSA-AES128-CCM8)128 bits** (recommended for embedded devices)

* **ECDSA private key and self-signed certificate:** The key and certificate is generated by the host and then uploaded to the device. This will allow Server-client authentication

* **The HANDSHAKE**:

  The host logs into the WebREPL and then starts the ssl_repl (this switch the terminal IO from WebREPL to SSLREPL) 

  Then the handshake is done by SSL sockets 

* **E2EE communication**

  Since this uses SSL sockets, all communication is encrypted.

### SSLWebREPL : shell/repl

The SSLWebREPL allows to toggle between shell and repl modes (Use 'CTRL-s' and then press 'ENTER' to do this)

The repl mode has two limitations:

- It is not listening actively for output (This means that if a timer/hardware interrupt callback print something it will not appear in the repl). To active listening for this kind of output do CTRL-g, to stop actively listening do CTRL-c

- To define a function/class or make a loop use the paste mode. (CTRL-E)

  *However the original WebREPL Terminal can be accesed from shell with 'wrepl' command*

  e.g.

  ```
  esp32@esp_room1:~ $ wrepl
  WARNING: ENCRYPTION DISABLED IN THIS MODE
  <-- Device esp32 MicroPython -->
  Use CTRL-x to exit, Use CTRL-k to see custom wrepl Keybdings
  Password:
  WebREPL connected
  >>>
  MicroPython v1.12 on 2019-12-20; ESP32 module with ESP32
  Type "help()" for more information.
  >>>
  >>>
  ```

  

**To see keybindings / shell commands info do 'CTRL-k': This will print**:

Custom keybindings:
- CTRL-x : to exit SSLWebREPL Terminal
- CTRL-p : toggle RAM STATUS right aligned message (USED/FREE)
- CTRL-e : paste mode in repl, (in shell mode set cursor position at the end)/(edit mode after 'edit' shell command)
- CTRL-d : ends paste mode in repl, (ends edit mode after 'edit' shell command)
- CTRL-c : KeyboardInterrupt, in normal mode, cancel in paste mode
- CTRL-b : prints MicroPython version and sys platform
- CTRL-r : to flush line buffer
- CTRL-o : to list files in cwd (sz shorcut command)
- CTRL-n : shows mem_info()
- CTRL-y : gc.collect() shortcut command
- CTRL-space : repeats last command
- CTRL-t : runs test_code.py if present
- CTRL-w : flush test_code from sys modules, so it can be run again
- CTRL-a : set cursor position at the beggining
- CTRL-f : toggle autosuggest mode (Fish shell like)
- CTRL-g : To active listen for device output (Timer or hardware interrupts), CTRL-c to break
- CRTL-s , ENTER : toggle shell mode to navigate filesystem (see shell commands)
- CTRL-k : prints the custom keybindings (this list) (+ shell commands if in shell mode)

Autocompletion commands:
- tab to autocomplete device file / dirs names / raw micropython (repl commands)
- shift-tab to autocomplete shell commands
- shift-right to autocomplete local file / dirs names
- shift-left,ENTER to toggle local path in prompt

Device shell commands:
* upysh commands:
    - sz   : list files and size in bytes
    - head : print the head of a file
    - cat  : prints the content of a file
    - mkdir: make directory
    - cd   : change directory (cd .. to go back one level)
    - pwd  : print working directory
    - rm   : to remove a file
    - rmdir: to remove a directory

* custom shell commands:
    - ls  : list device files in colored format (same as pressing tab on empty line)(allows "*" wildcard or directories)
    - tree : to print a tree version of filesystem (to see also hidden files/dirs use 'tree -a')
    - run  : to run a 'script.py'
    - df   : to see filesystem flash usage (and SD if already mounted)
    - du   : display disk usage statistics (usage: "du", "du [dir or file]" + '-d' deep level option)
    - meminfo: to see RAM info
    - whoami : to see user, system and machine info
    - datetime: to see device datetime (if not set, will display uptime)
    - set_localtime : to set the device datetime from the local machine time
    - ifconfig: to see STATION interface configuration (IP, SUBNET, GATEAWAY, DNS)
    - ifconfig_t: to see STATION interface configuration in table format
                  (IP, SUBNET, GATEAWAY, DNS, ESSID, RSSI)
    - netscan: to scan WLANs available, (ESSID, MAC ADDRESS, CHANNEL, RSSI, AUTH MODE, HIDDEN)
    - uping : to make the device send ICMP ECHO_REQUEST packets to network hosts (do 'uping host' to ping local machine)
    - apconfig: to see ACCESS POINT (AP) interface configuration (IP, SUBNET, GATEAWAY, DNS)
    - apconfig_t: to see ACCESS POINT (AP) interface configuration in table format
                 (SSID, BSSID, CHANNEL, AUTH, IP, SUBNET, GATEAWAY, DNS)
    - install: to install a library into the device with upip.
    - touch  : to create a new file (e.g. touch test.txt)
    - edit   : to edit a file (e.g. edit my_script.py)
    - get    : to get a file from the device (also allows "*" wildcard, 'cwd' or multiple files)
    - put    : to upload a file to the device (also allows "*" wildcard, 'cwd' or multiple files)
    - sync   : to get file (faster) from the device (use with > 10 KB files) (no encrypted mode only)
    - d_sync: to recursively sync a local directory with the device filesystem
    - wrepl  : to enter the original WebREPL terminal (no encryption mode)
    - reload : to delete a module from sys.path so it can be imported again.
    - flush_soc: to flush socket in case of wrong output
    - view   : to preview '.pbm' binary image files (image need to be centered and rows = columns) (encryption mode only)
    -  bat    : prints the content of a '.py' file with Python syntax hightlighting (named after https://github.com/sharkdp/bat)
    - rcat   : prints the raw content of a file (encryption mode only)
    - exit   : to exit SSLWebREPL Terminal (in encrypted mode soft-reset by default)
             to exit without reset do 'exit -nr'
             to exit and do hard reset 'exit -hr'
* Local shell commands:
    - pwdl   : to see local path
    - cdl    : to change local directory
    - lsl    : to list local directory
    - catl   : to print the contents of a local file
    - batl   : prints the content of a local '.py' file with Python syntax hightlighting
    - l_micropython: if "micropython" local machine version available in $PATH, runs it.
    - python : switch to local python3 repl
    - vim    : to edit a local file with vim  (e.g. vim script.py)
    - l_ifconfig: to see local machine STATION interface configuration (IP, SUBNET, GATEAWAY, DNS)
    - l_ifconfig_t: to see local machine STATION interface configuration in table format
                  (IP, SUBNET, GATEAWAY, DNS, ESSID, RSSI)
    - lsof : to scan TCP ports of the device (TCP ports 1-10000)
    - docs : to open MicroPython docs site in the default web browser, if a second term
            is passed e.g. 'docs machine' it will open the docs site and search for 'machine'
    - getcert: to print the client SSL Certificate
    - get_rawbuff: to get the raw output of a command (for debugging purpose)
    - ldu  : display local path disk usage statistics (usage: "du", "du [dir or file]" + '-d' deep level option)
    - upipl : (usage 'upipl' or 'upipl [module]' display available micropython packages that can be installed with install command
    - pkg_info: to see the PGK-INFO file of a module if available at pypi.org or micropython.org/pi
    - lping : to make local machine send ICMP ECHO_REQUEST packets to network hosts (do 'lping dev' to ping the device)

Some examples of these commands:

```
esp32@esp_room1:~ $ df
Filesystem      Size        Used       Avail        Use%     Mounted on
Flash          2.0 MB     636.0 KB     1.4 MB     31.4 %     /
esp32@esp_room1:~ $ cd lib
esp32@esp_room1:~/lib$ ls
client.py                   logging.py
protocol.py                 ssl_repl.py
sync_tool.py                upylog.py
upynotify.py                upysecrets.py
upysh2.py
esp32@esp_room1:~/lib$ meminfo
Memmory         Size        Used       Avail        Use%
RAM          116.188 KB  17.984 KB   98.203 KB    15.5 %
esp32@esp_room1:~/lib$ cd
esp32@esp_room1:~ $ cd test_sync_dir
esp32@esp_room1:~/test_sync_dir$ tree
  ATEXTFILE.txt
  THETESTCODE.py
  my_other_dir_sync <dir>
        └────  another_file.txt
  new_tree_test_dir <dir>
        ├────  example_code.py
        ├────  foo_file.txt
        ├────  sub_foo_test_dir <dir>
        │    ├────  file_code.py
        │    └────  foo2.txt
        ├────  w_name_dir <dir>
        │    └────  dummy_file.txt
        └────  zfile.py
  test_subdir_sync <dir>
        ├────  SUBTEXT.txt
        └────  sub_sub_dir_test_sync <dir>
             ├────  level_2_subtext.txt
             └────  level_3_subtext.txt
6 directories, 12 files
esp32@esp_room1:~/test_sync_dir$ cat THETESTCODE.py
# This is a MicroPython script
print('DSYNC WORKS!')
# define a function in edit mode now
def my_test_func():
    print('This is a function defined in edit mode with tab indentation')
for i in range(10):
    my_test_func()
for i in range(5):
    print('test finish')
esp32@esp_room1:~/test_sync_dir$ run THETESTCODE.py
DSYNC WORKS!
This is a function defined in edit mode with tab indentation
This is a function defined in edit mode with tab indentation
This is a function defined in edit mode with tab indentation
This is a function defined in edit mode with tab indentation
This is a function defined in edit mode with tab indentation
This is a function defined in edit mode with tab indentation
This is a function defined in edit mode with tab indentation
This is a function defined in edit mode with tab indentation
This is a function defined in edit mode with tab indentation
This is a function defined in edit mode with tab indentation
test finish
test finish
test finish
test finish
test finish
esp32@esp_room1:~/test_sync_dir$ exit
Rebooting device...
Done!
logout
Connection to 192.168.1.42 closed.
```

